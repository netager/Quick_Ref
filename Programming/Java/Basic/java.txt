
## class & instance
  - 클래스(static 코드) -> 생성(인스턴스화) -> 인스턴스(dynamic memory)

## 클래스 생성하기 
  - 클래스를 사용하기 위해서는 클래스를 생성하여야 함
  - new 예약어를 이용하여 클래스 생성 
  - 클래스형 변수이름 = new 생성자;
    - Student studentA = new Student();
	
## 인스턴스와 힙(heap) 메모리 - 동적 메모리 공간 
  - new 키워드를 통해 생성되면 heap 메모리 사용 
  - 하나의 클래스 코드로 부터 여러 개의 인스턴스를 생성 
  - 인스턴스는 힙(heap) 메모리에 생성됨.
  - 각각의 인스턴스는 다른 메모리에 다른 값을 가짐  

## 클래스, 인스턴스, 참조변수, 참조 값 
  - 객체 - 객체 지향 프로그램의 대상, 생성된 인스턴스 
  - 클래스 - 객체를 프로그래밍하기 위해 코드로 만든 상태
  - 인스턴스 - 클래스가 메모리에 생성된 상태
  - 멤버 변수 - 클래스의 속성, 특성
  - 메서드 - 멤버 변수를 이용하여 클래스의 기능을 구현
  - 참조 변수 - 메모리에 생성된 인스턴스를 가리키는 변수 
  - 참조 값 - 생성된 인스턴스의 메모리 주소 값 
 
## 생성자(constructor)
  - 인스턴스 생성 시 new 키워드와 함께 사용했던 생성자 
  - 생성자 기본 문법 
    - <modifiers><class_name>([<argument_list>])
       {
			[<statements>]
		}
  - 생성자는 인스턴스를 초기화 할 때의 명령어 집합 
  - 생성자의 이름은 그 클래스의 이름과 같음
  - 생성자는 메소드가 아님. 상속되지 않으며, 리턴값은 없음.

## 디폴트 생성자(default constructor)
  - 하나의 클래스에는 반드시 적어도 하나 이상의 Constructor가 존재
  - 프로그래머가 Constructor를 기술하지 않으면 Default Constructor가 자동으로 생김(컴파일러가 코드에 넣어줌)
  - Default Constructor는 매개 변수가 없음 
  - Default Constructor는 구현부가 없음 
  - 만약 클래스에 매개변수가 있는 생성자를 추가하면 디폴트 생성자는 제공되지 않음.
  
  
## 생성자 오버로드(constructor overload)
  - 필요에 의해 생성자 추가 하는 경우 여러 개의 생성자가 하나의 클래스에 있음(overload)

	
## 참조 자료형(reference data type)
  - 변수의 자료형
    - 기본 자료형 : int, long, float, double 등 
	- 참조 자료형 : String, Date, Student 등 (클래스 형으로 선언하는 자료형)

## 참조 자료형의 예 
  - 학생의 속성 중 수업에 대한 부분 
  - 수업에 대한 각 속성을 학생 클래스에 정의 하지 않고 수업이라는 클래스로 분리해서 사용 
    이때 과목은 참조 자료형으로 선언 
	

## 정보은닉(information hiding)
  - private 접근 제어자 
    - 클래스의 외부에서 클래스 내부의 멤버 변수나 메서드에 접근(access)하지 못하게 하는 경우 사용 
    - 멤버 변수나 메서드를 외부에서 사용하지 못하도록 하여 오류를 출일 수 있음.
    - 변수에 대해서는 필요한 경우 get(), set() 메서드 제공 
    - class 내부에서만 볼 수 있음 
  - default 접근 제어자 
    - 접근 제어자 없이 사용하는 것을 default 접근 제어자라 함
    - 패키지 내에서만 볼 수 있음
  - protected 접근 제어자 
    - 패키지가 달라도 상속을 받은 경우 볼 수 있음
	- 같은 패키지 내에서도 볼 수 있음
  - public
    - 다 볼 수 있음 

  
6. 클래스와 객체2

## this 가하는 일
  - 자신의 메모리를 가리킴
  - 생성자에서 다른 생성자를 호출
  - 자신의 주소를 반환 함  
  
## 자신의 메모리를 가리키는 this 
  - public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
  - 위 코드에서 this를 생략하게 되면 name이나 age는 파라미터로 사용되는 name과 age로 인식된다.

## 생성자에서 다른 생성자를 호출 하는 this 
  - public Person() {
		this("이름없음", 1);
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
  - this를 이용하여 다른 생성자를 호출할 때는 그 이전에 어떠한 statement도 사용할 수 없다.
    위와같이 생성자가 여러개이고 파라미터만 다른 경우 constructor overloading 이라고 한다.

## 객체 간의 협력 
  - 학생이 버스나 지하철을 가는 상황을 객체 지향으로 프로그래밍 
    - 학생 -> 버스를 탄다 -> 버스 
    - 학생 -> 지하철을 탄다 -> 지하철
  - 학생 class, 버스 class, 지하철 class
    - 학생의 속성 : 이름, 돈, 학년
	- 버스의 속성 : 버스번호, 승객수, 수익금
	- 지하철 속성 : 노선번호, 승객수, 수익금
	- 학생 - 버스 : 학생은 돈을 내고, 버스의 수익금, 버스의 승객수 증가
	- 학생 - 지하철 : 학생은 돈을 내고, 지하철 수익금 증가, 승객수 증가
	- 메서드 
	  - 탄다, 정보 출력 
	  - 태운다, 정보 출력            

## static 변수
  - static 변수 
    - static 변수의 정의와 사용 방법 
      - static 예약어  자료형   변수 이름 
      - static int serialNum;
  - 여러 개의 인스턴스가 같은 메모리 값을 공유하기 위해 사용
  - static 변수는 인스턴스가 생성될 대 마다 다른 메모리를 가지는 것이 아니라 프로그램이 메모리에 적재(load)
    될때 데이터 영역의 메모리에 생성 됨. 따라서 인스턴스의 생성과 관계없이 클래스 이름으로 직접 참조 함.
	- Student.serialNum = 100; // serialNum이 static 변수 
  - 클래스 변수라고도 함 
  - 멤버변수는 다른 말로 인스턴스 변수라고 함.

## static 변수 Vs. 인스턴스 변수 
  - serialNumber를 static 으로 선언하면 모든 student instance에 대해 하나의 변수로 유지 되고 
    이러한 변수를 class 변수라 한다.

## static 변수 예 
  - 여러 인스턴스가 하나의 메모리 값을 공유할 때 필요 
  - 학생이 생성될 때마다 학번이 증가해야 하는 경우 기준이 되는 값은 static 변수로 생성하여 유지 함.

  - 각 학생이 생성될 때 마다 static 변수 값을 복사해 와서 하나 증가시킨 값을 생성된 인스턴스의 학번 변수에 저장해 줌.

## 변수의 유효 범위
  - 지역변수(로컬변수)
    - 선언 위치 - 함수 내부에 선언
    - 사용 범위 - 함수 내부에서만 사용
    - 메모리   - 스택
    - 생성과 소멸 - 함수가 호출될때 생성되고 함수가 끝나면 소멸함
  - 멤버변수(인스턴스변수)   
    - 선언위치   - 클래스 멤버 변수로 선언
    - 사용범위   - 클래스 내부에서만 사용하고 private이 아니면 참조 변수로 다른 클래스에서 사용 가능
    - 메모리     - 힙
    - 생성과 소멸 - 인스턴스가 생성될 때 힙에 생성되고, 가비지 컬렉터가 메모리를 수거할 때 소멸됨
  - static 변수(클래스 변수)
    - 선언위치 - static 예약어를 사용하여 클래스 내부에 선언
    - 사용범위 - 클래스 내부에서 사용하고 private이 아니면 클래스 이름으로 다른 클래스에서 사용 가능 
    - 메모리   - 데이터 영역 
    - 생성과 소멸 - 프로그램이 처음 시작할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나고 메모리를 해제할 때 소멸됨.	
  
## static 응용 : singleton 패턴 
  - 자동차 회사가 있고 자동차 회사에는 직원들이 있고 자동차 회사에는 여러 개의 공장들이 있고 생산된 자동차를
    운반하는 운반차들이 있다.
  - 위에서 객체는 무엇이고, 이 중에 자동차 회사시스템을 만들 때 단 한개만이 존재하는 객체는 무엇인가?
    - 자동차 회사 
  - 예) 날짜같은 경우 단 하나 임.
  - 전 시스템에 단 하나의 인스턴스만이 존재하도록 구현하는 방식 
    - 자바는 글로벌 변수가 없다 -> static 변수 사용 
    - 생성자가 없으면 public default 생성자가 생성된다 -> 생성자를 private로 만듬
    - 외부에서 생성된 static으로 생성된 객체를 사용할 수 있어야 한다 -> public으로 선언된 static메서드 제공 

7. 배열과 ArrayList
## 배열은 왜 써야 할까?
  - 정수 20개를 이용한 프로그램을 할 때 20개의 정수 타입의 변수를 선언해야 한다.
    - int num1, int num2, int num3 ... num20;
  - 비효율적이고 변수관리도 힘들다.
    - 배열은 동일한 자료형의 변수를 한꺼번에 순차적으로 관리할 수 있다. 

## 배열 선언하기 
  - 자료형[] 배열이름 = new 자료형[개수]; - 요걸 자주 사용함.
    - int[] arr = new int[10];
  - 자료형 배열이름[] = new 자료형[개수];
    - int arr[] = new int[10];

## 배열의 초기화 
  - 배열은 선언과 동시에 초기화 할 수 있음.
  - 배열을 초기화 할 때는 배열의 개수를 명시하지 않음 
    - int[] studentIDs = new int[] {101, 102, 103}; // 개수를 생략함
	- int[] studentIDs = new int[3] {101, 102, 103}; // 오류 발생 
	- int[] studentIDs = {102, 103, 104}; // int형 3개인 배열 생성 
  - 아무런 초기화 값이 없이 선언만 한 경우, 정수는 0, 실수는 0.0 객체 배열은 null로 초기화 됨
  
## 배열 사용하기
  - [] : 인덱스 혹은 첨자 연산자
         배열의 위치를 지정하여 자료를 가져옴
         모든 배열의 순서는 0부터 시작 함
         n개 배열은 0부터 n-1위치까지 자료가 존재 
  - 예) int[] num = new int[] {1,2,3,4,5,6,7,8,9,10}; 

## 배열의 길이와 유효한 요소 값 
  - 배열 길이의 속성 : length
  - 자료가 있는 요소만 출력하려면 크기에 대한 저장을 따로 해야 함 (아래 예제에서 전체 길이로 곱하기 하면 값은 0.0이 되어 버림)
  
## 객체 배열 만들기 
  - 참조 자료형을 선언하는 객체 배열 
  - 배열만 생성 한 경우 요소는 null로 초기화 
  - 각 요소를 new를 활용하여 생성하여 저장해야 함.  

## 배열 복사하기 
  - 기존 배열과 같은 배열을 만들거나 배열이 꽉 찬 경우 더 큰 배열을 만들고 기존 배열 자료를 복사할 수 있음.
  - System.arrarycopy(src, srcPos, dest, destPos, length);
    - src - 복사할 배열 이름 
	- srcPos - 복사할 배열의 첫 번째 위치 
	- dest - 복사해서 붙여 넣을 대상 배열 이름 
	- destPos - 복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치 
	- length - src에서 dest로 자료를 복사할 요소 개수 

## 객체 배열 복사하기 
  - 얕은 복사 : 배열 요소의 주소만 복사 되므로 배열 요소가 변경되면 복사된 배열의 값도 변경 됨. 
  
## 객체 배열의 깊은 복사 
  - 별도의 인스턴스를 생성하고 복사  
  

## 향상된 for 문(enhanced for loop)
  - 배열 요소의 처음부터 끝까지 모든 요소를 참조할 때 편리한 반복문
  - for(변수 : 배열) { 반복 실행문; }
    - for(String s : strArray) { 실행문; }

## 다차원 배열 
  - 2차원 이상의 배열
  - 지도, 게임 등 평면이나 공간을 구현할 때 많이 사용 됨
  - 이차원 배열의 선언과 구조 
    - int[][] arr = new int[2][3];
  - 선언과 초기화 
    - int[][] arr = {{1,2,3},{4,5,6}}

## ArrayList 클래스 
  - 기존 배열은 길이를 정하여 선언하므로 사용 중 부족한 경우 다른 배열로 복사하는 코드를 직접 구현해야 함 
  - 중간의 요소가 삭제되거나 삽입되는 경우도 나머지 요소에 대한 조정하는 코드를 구현해야 함.

  - ArrayList 클래스는 자바에서 제공되는 객체 배열이 구현된 클래스 
  - 여러 메서드와 속성 등을 사용하여 객체 배열을 편리하게 관리할 수 있음
  - 가장 많이 사용하는 객체 배열 클래스 

## ArrayList 클래스 주요 메서드 
  - boolean add(E e) 요소 하나를 배열에 추가합니다. E는 요소의 자료형을 의미함.
  - int size() - 배열에 추가된 요소 전체 개수를 반환함.
  - E get(int index) - 배열의 index 위치에 있는 요소 값을 반환 
  - E remove(int index) - 배열의 index 위치에 있는 요소 값을 제거하고 그 값을 반환함.
  - boolean isEmpty() - 배열이 비어있는지 확인   
  
## ArrayList 클래스 사용하기 
  - ArrayList<E> 배열이름 = new ArrayList<E>();
  - 사용할 객체를 E 위치에 넣고 ArrayList 메서드를 활용하여 추가하거나 참조할 수 있음.


8. 상속과 다형성
## 상속이란?
  - 클래스를 정의할 때 이미 구현된 클래스를 상속(inheritance) 받아서 속성이나 기능이 확장되는 클래스를 구현함.
  - 상속하는 클래스 : 상위 클래스, parent class, base class, super class
  - 상속 받는 클래스 : 하위 클래스, child class, derived class, subclass
  - 클래스 상속 문법
    - class B extends A {}

## 상속이란?
  - 상위 클래스는 하위 클래스 보다 일반적인 의미를 가짐 
  - 하위 클래스는 상위 클래스 보다 구체적인 의미를 가짐 
  - 포유류 <- 사람
    - class Mammal{}
    - class Human extends Mammal {}
  - extends 뒤에는 단 하나의 class만 사용할 수 있음
  - 자바는 single inheritance만을 지원 함.

## 상속을 활용한 고객관리 프로그램 
  - 고객의 정보를 활용하여 고객 맞춤 서비스를 구현 
  - 고객의 등급에 따라 차별화 된 할인율과 포인트를 지급 
  - 등급에 따른 클래스를 따로 구현하는 것이 아닌 일반적인 클래스를 먼저 구현하고 그 보다 기능이 많은
    클래스는 상속을 활용하여 구현함.
    - Customer <- VIP Customer 
               <- Gold Customer 

## 접근 제한자 가시성 

             | 외부 클래스 | 하위 클래스 | 동일 패키지 | 내부 클래스 
   ----------|----------|----------|---------------------		 
   public    | O        | O        | O        | O
   ----------|----------|----------|----------|----------
   protected | X        | O        | O        | O
   ----------|----------|----------|----------|----------
   선언되지 않음 | X        | X        | O        | O
   (default) |          |          |          |
   ----------|----------|----------|----------|----------
   private   | X        | X        | X        | O
   ----------|----------|----------|----------|----------   
   
## 상속에서의 메모리 상태 
  - 상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성 됨.
    - public class VIPCustomer extends Customer {}
	  - ① Customer() 생성자 호출 - Customer 클래스의 멤버 변수가 메모리에 생성됨 
	  - ② VIPCustomer() 생성자 호출 - VIPCustomer 클래스의 멤버변수가 메모리에 생성됨

## 상위 클래스로의 묵시적 형변환(업캐스팅)
  - 상위 클래스형으로 변수를 선언하고 하위 클래스 인스턴스를 생성할 수 있음
  - 하위 클래스는 상위 클래스 타입을 내포하고 있으므로 상위 클래스로 묵시적 형변환이 가능 함 
    - Customer vc = new VIPCustomer();
	
## 형 변환에서 메모리 
  - Customer vc = new VIPCustomer(); 에서 vc가 가리키는 것은?
  - VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성 되었지만 타입이 Customer이므로 접근할 수 있는 변수나
    메서드는 Customer 변수와 메서드임

## Java Decompile
  - cd workspace (작업디렉토리)
  - cd Chapter8\bin
  - javap -verbose inheritance.VIPCustomer > a.out 


## 메서드 오버라이딩(overrriding) 
  - 상위 클래스에 정의된 메서드 중 하위 클래스와 기능이 맞지 않거나 추가 기능이 필요한 경우 같은 이름과 매개변수로 하위 클래스에서
    재정의 함.
  - VIPCustomer 클래스의 calcPrice() 메서드 재정의 
    - public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	  }
	- 보너스 포인트 적립하고 할인률을 적용한 가격을 반환 
	
## 묵시적 형변환과 재정의 된 메서드 호출
  - Customer vc = new VIPCustomer();
    vc.calcPrice(10000);

  - 위 코드에서 calcPrice() 메서드는 어느 메서드가 호출 될 것인가? 재정의 된 메서드 호출 

## 가상 메서드(virtual method)
  - 프로그램에서 어떤 객체의 변수나 메서드의 참조는 그 타입에 따라 이루어짐. 가상 메서드의 경우는 타입과 상관없이 실제 생성된 
    인스턴스의 메서드가 호출 되는 원리 
	- Customer vc = new VIPCustomer();
	  vc.calcPrice(10000);
	- vc의 타입은 Customer 이지만, 실제 생성된 인스턴스인 VIPCustomer 클래스의 calcPrice() 메서다가 호출 됨. 

## 다형성(polymorphism)
  - 하나의 코드가 여러가지 자료형으로 구현되어 실행되는 것 
  - 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나 
  - 객체지향 프로그래밍의 유연성, 재활용성, 유지보수성에 기본이 되는 특징임.

## 다형성 구현 하기 
  - 하나의 클래스를 상속 받은 여러 클래스가 있는 경우 
  - 각 클래스마다 같은 이름의 서로 다른 메서드를 재정의 함 
  - 상위 클래스 타입으로 선언된 하나의 변수가 여러 인스턴스에 대입되어 다양한 구현이 실행될 수 있음. 
  
## 다형성 활용하기 
  - 일반 고객과 VIP 고객의 중간 등급의 고객을 생성 
  - 5명의 고객을 ArrayList에 생성하여 저장한 다음 각 고객이 물건을 샀을 때의 가격과 보너스 포인트를 개산 함. 

## 상속을 언제 사용할까?
  - 여러 클래스를 생성하지 않고 하나의 클래스에 공통적인 요소를 모으고 나머지 클래스는 이를 상속받은 다음 필요한 특성과 메서드를
    구현하는 방법
  - 하나의 클래스에 여러 특성을 한꺼번에 구현하는 경우 많은 코드 내에 많은 if문이 생길수 있음 
  


  
## 01. 객체지향 프로그래밍의 시작 캡슐화
	- 객체지향 프로그래밍(OOP-Object Oriented programming)
		- OOP의 기본 컨셉은 프로그램 내에서 표현하고자 하는 실 세계(real world)의 일들을 객체를 사용해서
		  모델링하고, 객체를 사용하지 않으면 불가능 혹은 무지 어려웠을 일들을 쉽게 처리하느 방법을 제공한다는 것
		  입니다.
	- 객체란? 클래스란?
	- 프로그램이란 ... 절차가 전부이다.
		- 프로그램 --- 방법1 --- 방법2 --->
		- 절차적인 프로그래밍? + 구조적인 프로그램밍? + 어떤 문제가 있었으며 새로운 방식이 필요했을 것이다 + 객체지향 프로그래밍?
	- 캡슐화
		- 프로그래밍은 절차이다.
	- 함수의 개체수가 많아지는 문제와 수납 방법의 모색 
		- 어떻게 수납할 것인가?
	- 기능에 따라서 분리할 것인가? - 수납 공간은 파일(클래스 파일)

		- Input.java
			- inputExam(0
			- inputStudent()
			- inputOmok()
		- Sort.java
			- sortExams()
			- sortStudents()
			- sortOmoks()
		- draw.java
			- drawOmok()
			- drawBoard()
			- drawOmoks()
	- 데이터에 따라 분리할 것인가?
		- Exam.java
			- inputExam()
			- sortExam()
			- printExam()
		- Student.java
			- inputStudent()
			- printStudent()
			- searchStudent()
		- Omok.java
			- drawOmok()
			- putOmok()
			- drawOmoks() 
	- 어떤 방식이 더 바람직한 것 같나요?
		- 기능을 위주로 수납한 방식? 아니면 데이터를 위주로 수납한 방식?
			- 데이터를 기준으로 묶어주어야 바람직 함.
			- 구조화된 데이터를 사용하는 함수 모듈의 독립성을 침해하는 문제를 해결 할 수 있기 때문에
				- 함수 모듈의 독립성??
				- 함수는 외부의 수정에 절대 영향을 받아서는 안된다.
	- 코드 파일 관리방법
		- 	class Ellipse {
				int x, y, w, h;
				int color;
			}
			
			void draw(Ellipse ellipse) {
				printf("....", ellipse.x);
				ellipse.x + ellipse.y 
			}
				-> 구조화된 데이터 Ellipse의 x가 변경되면 draw()에서 영향을 받는다.
				    (ellipse.x 가 변경되면 draw()에서 영향 받음)
					
		- 해결 방법
			1. 변수명을 바꾸지 않는다.
			2. 변수를 바꾸었으면 사용 되는 모든 코드를 찾아서 같이 변경.
			
			-> 둘다 좋지는 않다.
			3. 가장 좋은 해결방법
				- 변수를 사용하는 모든 함수를 함께 모아 놓는다.
				-	class Ellipse {
						int x, y, w, h;
						int color;
						
						void draw(Ellipse ellipse) {
							printf("....", ellipse.x);
							ellipse.x + ellipse.y 
						}
					}
				- 캡슐화를 하면 데이터 구조에 따른 코드의 수정범위를 캡슐 범위로 한정할 수 있다. 
	- 캡슐화 정리 : 데이터 구조와 함수를 하나의 영역에 함께 정의하는 것 
	
## 02. 함수들을 캡슐화 하기 - 성적관리 프로그램 캡슐화 하기 
	- 캡슐화 : 데이터 구조와 함수를 하나의 영역에 함께 모아 놓는 작업
	
## 03. 인스턴스(Instance) 메소드 
	- 객체와 함수의 관계
		- 	void main(){ // list를 이용한 처리 - 구조적 처리 - 함수적 처리
				list = new ExamList();
				ExamList.inputList(list);
				ExamList.printList(list);
				ExamList.saveList(list);
			
		-  	void main() { // 인스턴스 함수
				list = new ExamList(); // list를 이용한. 입력() - list야 입력해
				list.inputList();      // list를 이용한. 출력() - list야 출력해
				list.printList();      // list를 이용한. 저장() - list야 저장해
				list.saveList();
			}
		
## 04. 인스턴스(Instance) 메소드 구현하기 
	- 객체지향적인 함수 호출 방식으로의 변화하기 
		- 기존의 함수의 인스턴스 전달
			-	public static void main(String[] args) {
					ExamList list = new ExamList();
					ExamList.inputList(list);
				}
				
				class ExamList {  
					public static void inputList(ExamList list) { // static 메서드
						list.exams[list.current] = new Exam();
					}
		- 새로운 함수의 인스턴스 전달		
			- 	public static void main(String[] args) {
					ExamList list = new ExamList();
					list.inputList();
				
				class ExamList {  
					public void inputList() { // 인스턴스 메서드
						this.exams[this.current] = new Exam();
				}
				
		- static method Vs. instance method 
			- static method
				- 매개변수를 통한 처리 함수(메서드)
			- instance method 
				- 객체를 생성해서 호출하는 메서드
				
## 05. 캡슐의 은닉성과 접근 지정자 
	- 캡슐을 깨뜨리는 행위란?
		- 
			
	- 캡슐을 깨지 못하게 하는 도구 : 접근 제어 지시자
		----------------------------------------------
		접근지시자     | 동일 클래스 | 파생 클래스 | 외부 클래스
		----------------------------------------------
		private    |    O    |     X    |    X  
		----------------------------------------------
		protected  |    O    |     O    |    X 
		----------------------------------------------
		public     |    O    |     X    |    O
		----------------------------------------------
	
## 06. 생성자(Constructor)		
	- 객체 초기화
		-	class Program {
				public static void main() {
					ExamList list = new ExamList();
					list.init();
					list.inputList();
				}
			}
			
			class ExamList {
				private Exam[] exams;
				private int current;
				
				public void init() {
					exams = new Exam[3];
					current = 0;
				}
			}
	- 생성자 : 초기화를 위한 특별한 함수 
		- 생성자의 조건
			- 1. 객체가 생성 되자 마자 무조건 제일 먼저 실행되어야 만 한다.
			- 2. 생성될 때 단 한번만 실행 되어야 만 한다.
				- 	new ExamList();  ---> new ExamList + (); : ExamList 객체를 생성하고 함수 호출(())
			- 정의할 때의 함수명은 초기화 할 객체를 한정하기 위한 형식명칭이다. - 생성자는 함수명이 없다.	
				class ExamList {
					public ExamList() {  // 반환 타입 사용하지 않음
						exams = new Exam[3];
						current = 0;
					}
				}
				
## 07. 생성자 오버로드(Constructor Overload)
	- 두 개 이상의 생성자 
		-	class ExamList {
				private Exam[] exams;
				private int current;
				
				public ExamList() { // 기본 생성자
					exams = new Exam[3];
					current = 0;
				
				public ExamList(int size) { // overload 생성자
					exams = new Exam[size];
					current = 0;
				}
		- new ExamList();
		- new ExamList(10);
	- 생성자의 중복 제거
		-	class ExamList {
				private Exam[] exams;
				private int current;
				
				public ExamList() { // 생성자 중복 제거
					// exams = new Exam[3];
					// current = 0;
					this(3);
				
				public ExamList(int size) { // overload 생성자
					exams = new Exam[size];
					current = 0;
				}
	- 생성자를 하나도 정의하지 않는다면?
		-	class ExamList {
				private Exam[] exams;
				private int current;
				
				}
		- 기본 생성자를 컴파일러가 자동으로 만듬.
			- 참조변수에는 null
			- int 에는 0을 설정

	- 기본 생성자를 제거한다면? - 기본생성자는 정의하지 않고 overload 생성자만 정의.
		-	class ExamList {
				private Exam[] exams;
				private int current;
				
				public ExamList(int size) { // overload 생성자
					exams = new Exam[size];
					current = 0;
				}
		- 컴파일러가 기본 생성자를 자동으로 만들어 주지 않음.
		- new ExamList() 형식의 객체 생성은 허용 되지 않는다.

## 08. Getters와 Setters 그리고 이것을 써야하는 이유 
	- 캡슐을 깨는 유혹
		- 캡슐 안	
			public class Exam {
				private int kor;
				private int eng;
				private int math;
				
				public void setKor(int kor) {
					this.kor = kor;
				}
			}
				
		- 캡슐 밖
			public class Program {
				public static void main(String[] args) {
					Exam exam = new Exam();
					exam.kor = 30;     // exam.kor이 private로 정의되어서 에러가 발생함.
					                   // 캡슐을 깨는 행위 
					
					exam.setKor(30);   // Setter를 이용해서 값 설정
	
	- Getter/Setter의 용도가 무엇일까요?
		- 너무 비 효율적인거 아닌가? 더 복잡한데? 그냥 public 으로 하면 안되나?
			- 속성명이 변경되는 것 때문인가?       (X)
			- 데이터 구조가 변경되는 것 때문인가?    (O)
					
		- 데이터 구조가 변경된다는 말의 의미는?
			- 	public class Exam {
					private int kor;
					private int eng;
					private int math;
				
				}
			
			- 처음에 3개의 과목만 있었는데 seq, title, regDate 속성 추가 되었고 과목을 별도로 Subject 로 분리 
				- 	public class Exam {
						public Subject subject; // 과목을 별도 클래스로 분리
						
						private int seq;
						private String title;
						private Date regDate;
					}
					
					public class Subject {
						private int kor;
						private int eng;
						private int math;
					}
				- 구조가 깊어 짐. kor를 사용하던 클래스에서 변경이 필요.
					- 원래 사용하던 코드	
						System.out.print("국어:");
						exam.kor = scan.nextInt();
					- 변경 코드	
						System.out.print("국어:");
						exam.subject.kor = scan.nextInt(); // 구조가 변경 되었다고 함.
					- Getters/Setters를 사용했더라면?
						System.out.print("국어:");
						exam.setKor(scan.nextInt());
						
		- 구조가 변경되는 또 다른 예
			- 원을 표현하는 클래스
				-	public class Ellipse {
						private int x;
						private int y;
						private int width;
						private int height;
						private color;
						
						public void draw() {...}
						public boid resize() {...}
					}
				
				- 	public class Ellipse {
						private Point pos;
						private Size size;
						pribate int color;
					}	
					
## 09. Exam 클래스의 캡슐화 완성
	- 

## 10. UI 코드는 분리하는 것이 기본 
	- 캡슐을 더 나눌 것인지를 선택하세요.
		- 분리전
			- Program ----> ExamList ----> Exam
				- Program 
					- main()
				- ExamList
					- list:Exam[]
					- current:int 
					+ input() - 입력
						- 사용자로부터 입력 받은 성적을 목록에 추가하는 함수
						- input()은 input() + add()로 구성
					+ print() - 출력
						- 목록에서 성적을 꺼내서 그것을 사용자에게 출력하는 함수
						- print()는 get() + print()로 구성 
				- Exam 
					- kor:int
					- eng:int
					- math:int 
					+ total():int 
					+ avg():float

		- 입력/출력은 콘솔, 윈도우, 웹, 모바일을 통해서 처리 
			- UI가 달라져도 사용 - 따라서 분리할 필요가 있음.
				- add() 와 get()을 분리
		- 분리 중간 단계
			- Program ----> ExamConsole ----> ExamList ----> Exam					
				- Program 
					- main()
				- ExamConsole
					- list:Exam[]
					- current:int 
					+ input()
					+ print()
				- ExamList
					- list:Exam[]
					- current:int 
					+ add()
					+ get()
				- Exam 
					- kor:int
					- eng:int
					- math:int 
					+ total():int 
					+ avg():float
			
		- 분리후
			- Program ----> ExamConsole ----> ExamList ----> Exam					
				- Program 
					- main()
				- ExamConsole
					- list:ExamList
					+ input()
					+ print()
				- ExamList
					- list:Exam[]
					- current:int 
					+ add(Exam)
					+ get():Exam
				- Exam 
					- kor:int
					- eng:int
					- math:int 
					+ total():int 
					+ avg():float
					
## 15. Exam을 IS A 상속하기
	- NewlecExam(자식/하위/파생 클래스) ---> Exam(부모/상위/기반 클래스) 

## 16. Overrid(우선순위가 높은) 메소드
	- 

## 17. 자식 클래스의 객체 초기화
	- 부모를 가지는 클래스는 두 개의 객체를 생성한다.
		-	public class NewlecExam extends Exam {
			}

## 18. 참조형식과 호출되는 메소드의 관계
	- 객체의 참조 형식의 개수
		- NewlecExam ---> Exam
		- Exam exam = new Exam();
		- NewlecExam exam = new NewlecExam();
			
		- Exam exam = new NewlecExam(); (O) - NewlecExam 내의 Exam을 참조
		- NewlecExam exam = new Exam(); (X) 
	- 형식에 따른 재정의 함수 호출 관계
		-	

## 19. 참조형식과 호출되는 메소드의 관계 2 - 메소드의 관계 연습하기
	- 호출되는 함수의 윛 결정 문제
		-	public class A {
				public f1() {...}
				public f2() {...} 는 f3() 호출
				public f3() {...}
				public f4() {...} 는 f5() 호출
				public f5() {...}
			}
			
			pubic class B extends A {
				public f3() {...}
				public f5() {...} 는 f3() 호출
				public f6() {...}
				public f7() {...}
			}
			
			- 문제
				- B b = new B();
					- b.f6() // B의 f6() 호출
					- b.f2() // A.f2() 호출된후 B.f3() 호출 
			
			- 문제 
				- A a = new B();
					- a.f6()      // 에러가 남. A클래스 내에 f6()이 없으므로 에러 발생. 먼저 A 클래스에 f6()이 있으면 B클래스의 f6()이 호출됨.
					- ((B)a).f6() // 에러 없이 B클래스의 f6()이 호출됨.
					- a.f2()      // A.f2() 호출되고 B.f3()이 호출됨.
					- a.f4()      // A.f4() 호출되고 B.f5() 호출되고 A.f4() 호출되고 무한 반복됨.


		-	public class A {
				public f1() {...}
				public f2() {...} 는 f3() 호출
				public f3() {...}
				public f4() {...} 는 f5() 호출
				public f5() {...} 는 f2() 호출
			}
			
			pubic class B extends A {
				public f3() {...}
				public f4() {...} 는 A.f4() 호출
				public f6() {...}
				public f7() {...} 는 f2() 호출
			}

			- 문제
				- A a = new B();
					- a.f4() // B.f4() ---> A.f4() ---> A.f5() ---> A.f2() ---> B.f3()

01. 자바 프로그램 시작하기 

02. 변수와 자료형
02-1 컴퓨터는 데이터를 어떻게 표현할까?
## 컴퓨터에서 수를 표현하는 방법
  - 컴퓨터는 0과 1로만 데이터를 저장 함
  - bit(비트) - 컴퓨터가 표현하는 데이터의 최소 단위로 2진수 하나의 값을 저장할 수 있는 메모리 크기 
  - byte(바이트) - 1byte = 8bit

## 0과 1의 표현 - 2진수 
  - 컴퓨터는 0과 1로 자료를 표현한다. 따라서 숫자나 문자도 0과 1의 조합으로 표현된다.

## 음의 정수는 어떻게 표현할까?
  - 정수의 가장 왼쪽에 존재하는 비트는 부호비트 입니다.
    - MSB(Most Significant Bit) - 가장 중요한 비트라는 뜻  
  - 어떤 수의 음수는 어떤 수와 그 수의 음수를 더해서 0이 되어야 함.
    - 0000 0101 + 1000 0101 = 1000 1010
  - 음수를 만드는 방법은 2의 보수를 취한다.
    ① 1의 보수를 취한다. (00000101 -> 11111010)
    ② 1을 더한다. ( 11111010 -> 11111011)
    - 0000 0101 + 1111 1011 = 0000 0000 (0이 됨). 원래는 1 0000 0000 이 나오나 앞의 1이 truncate 됨.
    - 따라서 0000 0101의 음수는 1111 1011 이다.

## 변수 
  - 프로그래밍에서 값(Data)를 사용하기 위해 선언하는 것을 변수라 한다.
  - 프로그램에서 사용되는 자료를 저장하기 위한 공간
  - 할당 받은 메모리의 주소 대신 부르는 이름 
  - 프로그램 실행 중에 값 변경 가능 
  - 사용되기 이전에 선언 되어야 한다. 
  - variable 이라 함 

## 변수의 선언과 초기화 
  - int level;      // level 이라는 이름의 변수 선언 
  - int level = 0;  // level 변수 선언과 동시에 0으로 초기화 
  - int level;
    level = 10;
  - int의 역할 : level 변수의 데이터 타입을 정의 
  - int의 의미 : level은 정수이며 4바이트의 메모리 공간을 사용한다. 
  
## 변수 선언시 유의점 
  - 변수의 이름은 알파벳, 숫자, _, $로 구성된다.
  - 대소문자를 구분한다.
  - 변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용할 수 없다.
  - 이름 사이에 공백이 있을 수 없다. 
  - 변수의 이름을 정할 때는 변수의 역할에 어울리는, 의미 있는 이름을 지어야 한다.

## 변수가 저장되는 공간의 특성 - 자료형 
          정수형     문자형     실수형     논리형
	----------------------------------------	  
    1바이트 byte        -        -   boolean
	----------------------------------------	  	
    2바이트 short    char        -         -
	----------------------------------------	  
    4바이트 int         -    float         -
	----------------------------------------	  
    8바이트 long        -   double         -	
	----------------------------------------	 
  - 변수가 사용할 공간의 크기와 특성을 따라 자료형을 사용항 변수를 선언한다. 	

## byte 와 short
  - byte - 1바이트 단위의 자료형. 동영상, 음악 파일 등 실행 파일의 자료를 처리 할 때 사용하기 좋은 자료형 
  - short - 2바이트 단위의 자료형. 주로 c/c++ 언어와의 호환 시 사용 

## int 
  - 자바에서 사용하는 정수에 대한 기본 자료 형 
  - 4바이트 단위의 자료 형 
  - 프로그램에서 사용하는 모든 숫자(리터럴)은 기본적으로 int(4바이트)로 저장됨.  
  - 32비트를 초과하는 숫자는 long 형으로 처리해야 함.
  
## long 
  - 8바이트 자료형
  - 가장 큰 정수 자료형 
  - 숫자의 뒤에 L 또는 l을 써서 long형임을 표시해야 함. 
  - 예) int num = 12345678900; // 오류. int의 범위 넘은 값 대입 
       long num = 12345678900; // 오류.
       숫자(리터럴) 12345678900은 기본형이 int인데 int의 범위가 넘는 수 
       long num = 12345678900L; // OK. 소문자 l을 써도 되지만 숫자 1과 구분하기 위해 대문자 사용 
	   
## char - 문자 자료형 
  - 컴퓨터에서는 문자도 내부적으로는 비트의 조합으로 표현 
  - 자바에서는 문자를 2바이트로 처리 
  - 인코딩 - 각 문자에 따른 특정한 숫자 값(코드값)을 부여 
  - 디코딩 - 숫자 값을 원래의 문자로 변환 
    - 'A' ----> 인코딩 ----> 65, 65 ----> 디코딩 ----> 'A'

## 문자 세트 
  - 문자세트 - 문자를 위한 코드 값(숫자값) 들을 정해 놓은 세트 	
  - 아스키(ASCII) - 1바이트로 영문자, 숫자, 특수문자 등을 표현 함.
  - 유니코드(Unicode) - 한글과 같은 복작한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적
  - 문자를 변수에 저장하면 ?문자에 해당하는 코드 값이 저장됨 
  - 자바는 유니코드 UTF-16 인코딩 사용 함.


## float, double - 실수 자료형 
  - 부동 소수점 방식 : 실수를 지수부와 가수부로 표현함. 무한의 실수를 표현하기 위한 방식 
  - 0.1을 표현하는 방식 
    - 1.0(가수) * 10(밑수)^-1(지수)
	  - 밑수는 2, 10, 16 등을 주로 사용함.
  - 실수 자료형 
    - float(4바이트) - 부호비트(1bit)+지수부(8bit)+가수부(23bit)
	- double(8바이트) - 부호비트(1bit)+지수부(11bit)+가수부(52bit)

## boolean - 논리형 
  - 논리값 true(참), false(거짓)을 표현하는 자료형. boolean 으로 선언 
  
## 자료형 없이 변수 사용하기 (자바 10)
  - 자료형이 필요한 이유:
    - 변수를 선언 할때는 변수가 사용할 메모리 크기와 타입을 구분하기 위해 자료형을 사용 
  - 지역 변수 자료형 추론(local variable type inference)	
    - 변수에 대입되는 값을 보고 컴파일러가 추론 
	  - var num = 10;      -> int num = 10;
	  - var dNUM = 10.0;   -> double dNum = 10.0;
	  - var str = "hello"; -> String str = "hello";

## 상수 
  - 상수 - 변하지 않는 값(cf. 변수 - 변하는 값)
  - 상수를 선언 - final 키워드 사용 
    - final double PI = 3.14;
	  final int MAX_NUM = 100;
	  
  - final로 선언된 상수는 다른 값을 대입할 수 없음 
    - PI = 3.15; // 에러 발생. final로 정의된 상수이므로 변경 불가.

  - 프로그램 내에서 변경되지 말아야 하는 값을 상수로 선언 해 두고 혹 변경되는 경우 선언된 값만 수정 
  
## 리터럴(literal)
  - 리터럴 - 프로그램에서 사용한는 모든 숫자, 값, 논리 값. ex) 10, 3.14, 'A', true 등 
  - 리터럴에 해당되는 값은 특정 메모리 공간인 상수 풀(constant pool)에 있음 
  - 필요한 경우 상ㅇ수 풀에서 가져와서 사용 
  - 상수 풀에 저장 할 때 정수는 int로 실수는 double로 저장. 따라서 long 이나 float 값으로 
    저장해야 하는 경우 식별자(L, l, F, f)를 명시해야 함.
    
## 형변환(type conversion)
  - 자료형은 각각 사용하는 메모리 크기와 방식이 다름 
  - 서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어남
  - 묵시적 형변환(implicit Conversion) - 작은수에서 큰수로 덜 정밀한 수에서 더 정밀한 수로 대입되는 경우 
  
    - 정수                                  실수
	  byte -> short -> int -> long  -----> float -> double
	                    ^
						| 
	          char -----|
			  
	- ex) long num = 3; // int값에서 long으로 자동 형 변환
                        // L,l을 명시하지 않아도 됨 
  - 명시적 형변환(Explicit Conversion) - 묵시적 형변환의 반대의 경우. 변환되는 자료형을 명시해야함. 
               - 자료의 손실이 발생할 수 있음
    - ex) double dNum = 3.14;
          int num = (int)dNum; // 자료형 명시 	


		  
3. 자바의 여러 가지 연산자 

## 항과 연산자 
  - 항(operand)  - 연산에 사용되는 값 
  - 연산자(operator) - 항을 이용하여 연산하는 기호 
  
  - 항의 개수에 따른 연산자 구분 - 단항, 이항, 삼항 연산자 
  
## 대입 연산자(=)
  - 변수에 값을 대입하는 연산자
  - 연산의 결과를 변수에 대입 
  - 우선 순위가 가장 낮은 연산자 
  - 왼쪽 변수(lvalue)에 오른쪽 변수(값)(rvalue)를 대입 

## 부호 연산자
  - 단항 연산자
  - 양수/음수의 표현, 값의 부호를 변경 
  - 변수에 +, -를 사용한다고 해서 변수의 값이 변하는 것은 아님
  - 변수의 값을 변경하려면 대입연산자를 사용함.

## 산술 연산자 
  - +, -, *, /, %
  - %는 나머지를 구하는 연산자 
    - 숫자 n의 나머지는 0 ~ n-1 범위의 수 
    - 특정 범위 안의 수를 구할 때 종종 사용

# 증가 감소 연산자 
  - 단항 연산자
  - val = ++num;  // 먼저 num 값에 1 증가후 val 변수에 대입, ;이전에 증가
  - val = num++;  // val 변수에 기존 num값을 대입한후 num 값 1 증가, ;이후에 증가 

# 관계 연산자 
  - 이항 연산자 
  - >, <, >=, <-, ==, != 
  - 결과값은 True or False 

# 논리 연산자
  - 관계 연산자와 혼합하여 많이 사용 됨
  - 연산의 결과가 true(참), false(거짓)으로 반환 됨
  - &&(논리곱), ||(논리합), !(부정)   
  
# 단락 회로 평가(short circuit evaluation)
  - 논리 곱(&&)은 두 항이 모두 true일 때만 결과가 true
    => 앞의 항이 false이면 뒤 항의 결과를 평가하지 않아도 false임 
  - 논리 합(||)은 두 항이 모두 false 일 때만 결과가 false 
    => d앞의 항이 true이면 뒤 항의 결과를 평가하지 않아도 true 임 
	
# 복합 대입 연산자 
  - 대입 연사자와 다른 연산자를 함께 사용함.
  - 프로그램에서 자주 사용하는 연산자 
  - +=, -=, *=, /=, %=  
  
# 조건 연산자 
  - 삼항 연산자 
  - 조건 식의 결과가 true인 경우와 false인 경우에 따라 다른 식이나 결과가 수행됨. 
  - 제어문 중 조건문을 간단히 표현할 때 사용할 수 있음.
  - 조건식 ? 결과1 : 결과2;   
    - int num = (5 > 3) ? 10 : 20;

# 비트 연산자 
  - ~ : 비트의 반전(1의 보수)
  - & : 비트 단위 AND, 1 & 1 이면 1 반환 그외는 0 
  - | : 비트 단위 OR,  0 | 0 이면 0 반환 그외는 1
  - ^ : 비트 단튀 XOR, 두개의 비트가 서로 다른 경우에 1 반환 
  - << : 왼쪽 shift, a << 2 변수 a를 2비트 만큼 왼쪽으로 이동 
  - >> : 오른쪽 shift, a >> 2 변수 a를 2비트만큼 오른쪽 이동
  - >>> : 오른쪽 shift,  >> 동일한 연산자. 채워지는 비트가 부호와 상관없이 0임.
  
  - 비트 연산자는 정수에만 사용할 수 있다.

# 비트 연산자의 활용 
  - 마스크 : 특정 비트들은 가리고 몇 개의 비트들의 값만 사용할 때
  - 비트켜기 : 특정 비트들만을 1로 설정해서 사용하고 싶을 때 
    - 예) & 00001111(하위 4비트 중 1인 비트만 꺼내기)
  - 비트끄기 : 특정 비트들만을 0으로 설정해서 사용하고 싶을 때 
    - 예) | 11110000 (하위 4비트 중 0인 비트만 0으로 만들기)
  - 비트토글 : 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때 

  
4. 제어의 흐름 이해하기
## 조건문
  - 주어진 조건에 따라 다른 수행문이 실행되도록 프로그래밍 하는 것.
  - if 문 
    - if(조건식) {
		수행문;
	  }
  - if - else 문
    - if(조건식) {
		수행문1;
      }		
	  else {
		수행문2;
	  }
  - if-else if-else 문 
    - if(조건 1) {
		문장1;
      }	else if(조건 2) {
			문장2;	  
	  }	else {
		문장3;
	  }

## 조건문과 조건 연산자
  - 간단한 if-esle조건문은 조건 연산자로 구현할 수 있음.
  - if(a>b) max = a; else max = b;
  - max = (a>b) > a: b; 

# switch-case문
  - 조건식의 결과가 정수 또는 문자열의 값이고 그 값에 따라 수행문이 결정될 때 
    if-else if-else문을 대신하여 switch-case문을 사용할 수 있음.
    - switch(rank) {
			case 1 : medalColor = 'G';
				break;
			case 2 : medalColor = 'S'; 
				break;  
  			case 3 : medalColor = 'B';
				break;
			default : medalColor = 'A';
      }

## case문에 문자열 사용하기 
  - 자바7 부터 switch-case 문의 case 값에 문자열 사용 가능 
  

## 반복문
  - 주어진 조건이 만족 할 때까지 수행문을 반복적으로 수행함
  - while, do-while, for문이 있음
  - 조건의 만족과 반복 가능 여부에 대해 정확한 코딩을 해야 함.

## while문
  - 조건식이 참인 동안 수행문을 반복해서 수행 
  - while(조건식) {
		수행문1;
	}	
		수행문 2;

## for 문 
  - 반복문 중 가장 많이 사용하는 반복문
  - 주로 조건이 횟수인 경우에 사용 
  - 초기화식, 조건식, 증감식을 한꺼번에 작성 
    - for(초기화식; 조건식; 증감식) {
			수행문;
	  }

## for 문 수행 과정 
  - ① 초기화 수행 ② 조건식 검증 ③ 수행문 실행 ④증감식 수행 -> 반복 -> ② 조건식 검증 ③ 수행문 실행 ④증감식 수행  	  

## 각 반복문의 쓰임
  - while 문 
    - 하나의 조건에 대해 반복수행이 이루어질 때 사용 
    - 조건이 맞지 않으면 수행문이 수행되지 않음 
    - 주로 조건식이 true, false로 나타남	
  - do-while문 
    - 하나의 조건에 대해 반복수행이 이루어질 때 사용 
      단, 수행문이 반드시 한번 이상 수행됨.
  - for 문 
    - 수의 특정 범위, 횟수와 관련한 반복수행에서 주로 사용
	- 배열과 함께 많이 사용 

## 무한 반복 
  - while(true) { 수행문 };  // 가장 많이 사용 함.
  - do { 수행문; } while(true);
  - for (;;) { 수행문; }  
	
## 중첩된 반복문 (nested loop)
  - 반복문 내부에 또 반복문이 사용 됨.
  - 구구단의 예
     
## continue 문 
  - 반복문과 함께 쓰이며, 반복문 내부 continue 문을 만나면 이후 반복되는 부분을 수행하지 않고 
    조건식이나 증감식을 수행함.
  - 1부터 100까지 중 홀수만 더하는 예

## break 문
  - 반복문에서 break 문을 만나면 더 이상 반복을 수행하지 않고 반복문을 빠져 나옴
  - 중첩된 반복문 내부에 있는 겨우 가장 가까운 반복문 하나만 빠져 나옴.


제2장 자바의 핵심 - 객체지향 프로그래밍 

5. 클래스와 객체 
## 객체 지향프로그래밍과 클래스 
  - 객체(Object)란?
    - "의사나 행위가 미치는 대상" - 사전적 의미
    - 구체적, 추상적 데이터 단위 
  - 객체지향프로그래밍(Object Oriented Programming, OOP) 
    - 객체를 기반으로 하는 프로그래밍 
	- cf. 절차 프로그래밍(Procedural Programming), C언어

## 생활 속의 객체 예
  - 학교 가는 과정에 대한 절차적 프로그래밍
    - 일어남 -> 씻는다 -> 밥먹음 -> 버스 탐 -> 요금 지불 -> 학교 도착 : 시간의 흐름에 따른 프로그래밍 
  - 학교 가는 과정에 대한 객체 지향 프로그래밍 
    - 객체를 정의 
    - 객체의 기능 구현
    - 객체 사이의 협력 구현 	

## 클래스(class)
  - 클래스란?
    - 객체에 대한 속성과 기능을 코드로 구현 한 것
    - "클래스를 정의 한다" 라고 함
    - 객체에 대한 청사진(blueprint) 
  - 객체의 속성 
    - 객체의 특성, 속성, 멤버 변수 
    - property, attribute, member variable 
  - 객체의 기능 
    - 객체가 하는 기능들을 메서드로 구현 
    - method, member function 

## 클래스 정의 하기 
  - (접근자 제어자) class 클래스 이름 {
		멤버 변수;
		메서드;
	}
  - class 이름은 대문자로 시작 	
  - 학생 클래스의 예 
    - 속성 : 학번, 이름, 학년, 사는 곳 등  
	- 기능 : 수강신청, 수업듣기, 시험보기 등
  - class는 대부분 대문자로 시작 
  - 하나의 java 파일에 하나의 클래스를 두는 것이 원칙이나, 여러 개의 클래스가 같이 있는 경우 public 클래스는 
    단 하나이며, public 클래스와 자바 파일의 이름은 동일해야 함. 
  - 자바의 모든 코드는 class 내부에 위치 	
  
## 클래스의 속성
  - 클래스의 특징을 나타냄 
  - property, attribute라고도 함.
  - 자료형을 이용하여 멤버 변수로 선언 

## 자바 네이밍 
  - pagkage : 모두 소문자
  - class   : 대문자로 시작해서 단어가 바뀔때마다 대문자로 시작 
  - 변수     : 소문자로 시작해서 단어가 빠뀔때마다 대문자로 시작 
  - 메서드    : 소문자로 시작해서 단어가 빠뀔때마다 대문자로 시작
  
## 패키지
  - 소스의 묶음 - 패키지 구조는 소스를 어떻게 유지보수 할지 하이라키 구조로 만듬. 
  - 소스코드를 어떠한 계층 구조로 관리할 지 구성하는 것.
  
## 메서드 
  - 함수의 일종 
  - 객체의 기능을 제공하기 위해 클래스 내부에 구현되는 함수   
  - 함수란?
    - 하나의 기능을 수행하는 일련의 코드
	- 중복되는 기능은 함수로 구현하여 함수를 호출하여 사용함

## 함수 정의 하기
  - 함수를 코드로 구현 
  - 함수의 이름, 매개변수, 반환값을 선언하고 코드를 구현 함.
  - int add(int num1, int num2) {
		int result;
		result = num1 + num2;
		return result;
	}
  - 함수반환형 : 반환값의 자료형을 나타냄. 반한값이 없는 경우 void라고 씀.	 
  
## 함수와 스택 메모리 
  - 함수가 호출될 떄 사용하는 메모리 - 스택(stack)
  - 함수의 기능 수행이 끝나면 자동으로 반환되는 메모리 
  - 함수 호출과 스택 메모리 구조   
    - main() -> addNum() 호출
	
	- stack 
	  - main(), qustn(num1, num2, sum) -> addNum(), 변수(n1, n2, result) -> return에 의해서 addNum()영역 삭제 
  
## 함수를 왜 쓰나요?
  - 코드를 효율적으로 구현한기 위해서 사용 
  - 필요한 기능을 구현해 놓고 효율적으로 사용  
  - 하나의 기능을 하나의 함수이름으로 사용 
  
## 클래스에서 메서드 구현하기 
  - 클래스의 메서드는 멤버 변수를 사용하여 기능 구현 
  - 학생의 이름을 반환하는 메서드 
  
  
## class & instance
  - 클래스(static 코드) -> 생성(인스턴스화) -> 인스턴스(dynamic memory), 객체 

## 클래스 생성하기 
  - 클래스를 사용하기 위해서는 클래스를 생성하여야 함
  - new 예약어를 이용하여 클래스 생성 
  - 클래스형 변수이름 = new 생성자;
    - Student studentA = new Student();
	
## 인스턴스와 힙(heap) 메모리 - 동적 메모리 공간 
  - 인스턴스는 new 키워드를 통해 생성되며 heap 메모리 사용 
  - 하나의 클래스 코드로 부터 여러 개의 인스턴스를 생성 
  - 인스턴스는 힙(heap) 메모리에 생성됨.
  - 각각의 인스턴스는 다른 메모리에 다른 값을 가짐  

## 클래스, 인스턴스, 참조변수, 참조 값 
  - 객체 - 객체 지향 프로그램의 대상, 생성된 인스턴스 
  - 클래스 - 객체를 프로그래밍하기 위해 코드로 만든 상태
  - 인스턴스 - 클래스가 메모리에 생성된 상태
  - 멤버 변수 - 클래스의 속성, 특성
  - 메서드 - 멤버 변수를 이용하여 클래스의 기능을 구현
  - 참조 변수 - 메모리에 생성된 인스턴스를 가리키는 변수 
  - 참조 값 - 생성된 인스턴스의 메모리 주소 값 
 
## 생성자(constructor)
  - 인스턴스 생성 시 new 키워드와 함께 사용했던 생성자 
  - 생성자 기본 문법 
    - <modifiers><class_name>([<argument_list>])
       {
			[<statements>]
		}
  - 생성자는 인스턴스를 초기화 할 때의 명령어 집합 
  - 생성자의 이름은 그 클래스의 이름과 같음
  - 생성자는 메소드가 아님. 상속되지 않으며, 리턴값은 없음.

## 디폴트 생성자(default constructor)
  - 하나의 클래스에는 반드시 적어도 하나 이상의 Constructor가 존재
  - 프로그래머가 Constructor를 기술하지 않으면 Default Constructor가 자동으로 생김(컴파일러가 코드에 넣어줌)
  - Default Constructor는 매개 변수가 없음 
  - Default Constructor는 구현부가 없음 
  - 만약 클래스에 매개변수가 있는 생성자를 추가하면 디폴트 생성자는 제공되지 않음.
  
  
## 생성자 오버로드(constructor overload)
  - 필요에 의해 생성자 추가 하는 경우 여러 개의 생성자가 하나의 클래스에 있음(overload)

	
## 참조 자료형(reference data type)
  - 변수의 자료형
    - 기본 자료형 : int, long, float, double 등 
	- 참조 자료형 : String, Date, Student 등 (클래스 형으로 선언하는 자료형)

## 참조 자료형의 예 
  - 학생의 속성 중 수업에 대한 부분 
  - 수업에 대한 각 속성을 학생 클래스에 정의 하지 않고 수업이라는 클래스로 분리해서 사용 
    이때 과목은 참조 자료형으로 선언 
	

## 정보은닉(information hiding)
  - private 접근 제어자 
    - 클래스의 외부에서 클래스 내부의 멤버 변수나 메서드에 접근(access)하지 못하게 하는 경우 사용 
    - 멤버 변수나 메서드를 외부에서 사용하지 못하도록 하여 오류를 출일 수 있음.
    - 변수에 대해서는 필요한 경우 get(), set() 메서드 제공 
    - class 내부에서만 볼 수 있음 
  - default 접근 제어자 
    - 접근 제어자 없이 사용하는 것을 default 접근 제어자라 함
    - 패키지 내에서만 볼 수 있음
  - protected 접근 제어자 
    - 패키지가 달라도 상속을 받은 경우 볼 수 있음
	- 같은 패키지 내에서도 볼 수 있음
  - public
    - 다 볼 수 있음 

  
6. 클래스와 객체2

## this 가하는 일
  - 자신의 메모리를 가리킴
  - 생성자에서 다른 생성자를 호출
  - 자신의 주소를 반환 함  
  
## 자신의 메모리를 가리키는 this 
  - public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
  - 위 코드에서 this를 생략하게 되면 name이나 age는 파라미터로 사용되는 name과 age로 인식된다.

## 생성자에서 다른 생성자를 호출 하는 this 
  - public Person() {
		this("이름없음", 1);  // 생성자에서 다른 생성자 호출
	}
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
  - this를 이용하여 다른 생성자를 호출할 때는 그 이전에 어떠한 statement도 사용할 수 없다.
    위와같이 생성자가 여러개이고 파라미터만 다른 경우 constructor overloading 이라고 한다.

## 객체 간의 협력 
  - 학생이 버스나 지하철을 가는 상황을 객체 지향으로 프로그래밍 
    - 학생 -> 버스를 탄다 -> 버스 
    - 학생 -> 지하철을 탄다 -> 지하철
  - 학생 class, 버스 class, 지하철 class
    - 학생의 속성 : 이름, 돈, 학년
	- 버스의 속성 : 버스번호, 승객수, 수익금
	- 지하철 속성 : 노선번호, 승객수, 수익금
	- 학생 - 버스 : 학생은 돈을 내고, 버스의 수익금, 버스의 승객수 증가
	- 학생 - 지하철 : 학생은 돈을 내고, 지하철 수익금 증  가, 승객수 증가
	- 메서드 
	  - 탄다, 정보 출력 
	  - 태운다, 정보 출력            

## static 변수
  - static 변수 
    - static 변수의 정의와 사용 방법 
      - static 예약어  자료형   변수 이름 
      - static int serialNum;
  - 여러 개의 인스턴스가 같은 메모리 값을 공유하기 위해 사용
  - static 변수는 인스턴스가 생성될 때 마다 다른 메모리를 가지는 것이 아니라 프로그램이 메모리에 적재(load)
    될때 데이터 영역의 메모리에 생성 됨. 따라서 인스턴스의 생성과 관계없이 클래스 이름으로 직접 참조 함.
	- Student.serialNum = 100; // serialNum이 static 변수 
	- Student studentJ = new Student();
	  studentJ.serialNum 이라고 사용하지 않고 Student.serialNum이라고 사용함.
  - static 변수를 클래스 변수라고도 함. 멤버변수는 다른 말로 인스턴스 변수라고 함.

## static 변수 Vs. 인스턴스 변수 
  - serialNumber를 static 으로 선언하면 모든 student instance에 대해 하나의 변수로 유지 되고 
    이러한 변수를 class 변수라 한다.

## static 변수 예 
  - 여러 인스턴스가 하나의 메모리 값을 공유할 때 필요 
  - 학생이 생성될 때마다 학번이 증가해야 하는 경우 기준이 되는 값은 static 변수로 생성하여 유지 함.

  - 각 학생이 생성될 때 마다 static 변수 값을 복사해 와서 하나 증가시킨 값을 생성된 인스턴스의 학번 변수에 저장해 줌.
  
  - 데이터 영역[static]  - 스택 메모리[참조변수]  - 힙 메모리[인스턴스, 객체]

## static 메서드 
  - 클래스 메서드 라고도 함 
  - 메서드에 static 키워드를 사용하여 구현 
  - 주로 static 변수를 위한 기능 제공 
  - static 메서드에서 인스턴스 변수를 사용할 수 없음 
  - static 메서드도 인스턴스의 생성과 관계없이 클래스 이름으로 직접 메서드 호출 
    - Student.getSerialNum();  // getSerialNum()이 satic 메서드
  - 인스턴스의 변수의 경우 꼭 인스턴스가 먼저 생성되어야 하므로 static 메서드에서는 생성이 불확실한 인스턴스 변수를
    사용할 수 없음.
	
## 변수의 유효 범위
  - 지역변수(로컬변수)
    - 선언 위치 - 함수 내부에 선언
    - 사용 범위 - 함수 내부에서만 사용
    - 메모리   - 스택
    - 생성과 소멸 - 함수가 호출될때 생성되고 함수가 끝나면 소멸함
  - 멤버변수(인스턴스변수)   
    - 선언위치   - 클래스 멤버 변수로 선언
    - 사용범위   - 클래스 내부에서만 사용하고 private이 아니면 참조 변수로 다른 클래스에서 사용 가능
    - 메모리     - 힙
    - 생성과 소멸 - 인스턴스가 생성될 때 힙에 생성되고, 가비지 컬렉터가 메모리를 수거할 때 소멸됨
  - static 변수(클래스 변수)
    - 선언위치 - static 예약어를 사용하여 클래스 내부에 선언
    - 사용범위 - 클래스 내부에서 사용하고 private이 아니면 클래스 이름으로 다른 클래스에서 사용 가능 
    - 메모리   - 데이터 영역 
    - 생성과 소멸 - 프로그램이 처음 시작할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나고 메모리를 해제할 때 소멸됨.	
  
## static 응용 : singleton 패턴 
  - 자동차 회사가 있고 자동차 회사에는 직원들이 있고 자동차 회사에는 여러 개의 공장들이 있고 생산된 자동차를
    운반하는 운반차들이 있다.
  - 위에서 객체는 무엇이고, 이 중에 자동차 회사시스템을 만들 때 단 한개만이 존재하는 객체는 무엇인가?
    - 자동차 회사 
  - 예) 날짜같은 경우 단 하나 임.
  - 전 시스템에 단 하나의 인스턴스만이 존재하도록 구현하는 방식 
    - 자바는 글로벌 변수가 없다 -> static 변수 사용 
    - 생성자가 없으면 public default 생성자가 생성된다 -> 생성자를 private로 만듬
    - 외부에서 생성된 static으로 생성된 객체를 사용할 수 있어야 한다 -> public으로 선언된 static메서드 제공 
  - 회사는 단 하나의 인스턴스만 생성해야 하는 경우.(시간대 등). 이러한 구현을 static을 이용하여 사용. 단 하나만 생성되도록 구현.
    - public class Singleton {
		private static Singleton singleton = new Singleton();
		
		private Singleton() {
			System.out.println("인스턴스를 생성했습니다.");
		}
		
		public static Singleton getInstance() {
			if(singleton == null)
				singleton = new Singletonn();
			
			return singleton;
		}
	  }		
    
  

7. 배열과 ArrayList
## 배열은 왜 써야 할까?
  - 정수 20개를 이용한 프로그램을 할 때 20개의 정수 타입의 변수를 선언해야 한다.
    - int num1, int num2, int num3 ... num20;
  - 비효율적이고 변수관리도 힘들다.
    - 배열은 동일한 자료형의 변수를 한꺼번에 순차적으로 관리할 수 있다. 

## 배열 선언하기 
  - 자료형[] 배열이름 = new 자료형[개수]; - 요걸 자주 사용함.
    - int[] arr = new int[10];
	
  - 자료형 배열이름[] = new 자료형[개수];
    - int arr[] = new int[10];

## 배열의 초기화 
  - 배열은 선언과 동시에 초기화 할 수 있음.
  - 배열을 초기화 할 때는 배열의 개수를 명시하지 않음 
    - int[] studentIDs = new int[] {101, 102, 103}; // 개수를 생략함
	- int[] studentIDs = new int[3] {101, 102, 103}; // 오류 발생 
	- int[] studentIDs = {102, 103, 104}; // int형 3개인 배열 생성 
  - 아무런 초기화 값이 없이 선언만 한 경우, 정수는 0, 실수는 0.0 객체 배열은 null로 초기화 됨
  
## 배열 사용하기
  - [] : 인덱스 혹은 첨자 연산자
         배열의 위치를 지정하여 자료를 가져옴
         모든 배열의 순서는 0부터 시작 함
         n개 배열은 0부터 n-1위치까지 자료가 존재 
  - 예) int[] num = new int[] {1,2,3,4,5,6,7,8,9,10}; 

## 배열의 길이와 유효한 요소 값 
  - 배열 길이의 속성 : length
  - 자료가 있는 요소만 출력하려면 크기에 대한 저장을 따로 해야 함 (아래 예제에서 전체 길이로 곱하기 하면 값은 0.0이 되어 버림)
  
## 객체 배열 만들기 
  - 참조 자료형을 선언하는 객체 배열 
  - 배열만 생성 한 경우 요소는 null로 초기화 
  - 각 요소를 new를 활용하여 생성하여 저장해야 함.  

## 배열 복사하기 
  - 기존 배열과 같은 배열을 만들거나 배열이 꽉 찬 경우 더 큰 배열을 만들고 기존 배열 자료를 복사할 수 있음.
  - System.arraycopy(src, srcPos, dest, destPos, length);
    - src - 복사할 배열 이름 
	- srcPos - 복사할 배열의 첫 번째 위치 
	- dest - 복사해서 붙여 넣을 대상 배열 이름 
	- destPos - 복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치 
	- length - src에서 dest로 자료를 복사할 요소 개수 

## 객체 배열 복사하기 
  - 얕은 복사 : 배열 요소의 주소만 복사 되므로 배열 요소가 변경되면 복사된 배열의 값도 변경 됨. 
  
## 객체 배열의 깊은 복사 
  - 별도의 인스턴스를 생성하고 복사  
  

## 향상된 for 문(enhanced for loop)
  - 배열 요소의 처음부터 끝까지 모든 요소를 참조할 때 편리한 반복문
  - for(변수 : 배열) { 반복 실행문; }
    - for(String s : strArray) { 실행문; }

## 다차원 배열 
  - 2차원 이상의 배열
  - 지도, 게임 등 평면이나 공간을 구현할 때 많이 사용 됨
  - 이차원 배열의 선언과 구조 
    - int[][] arr = new int[2][3];
  - 선언과 초기화 
    - 	int[][] arr = {{1,2,3},{4,5,6}}
	
		for (int i=0; i < intArr.lenth; i++) {
			for (int j=0; j< intArr[i].length; j++) {
				System.out.println(intArr[i][j]);
			}
		}		

## ArrayList 클래스 
  - 기존 배열은 길이를 정하여 선언하므로 사용 중 부족한 경우 다른 배열로 복사하는 코드를 직접 구현해야 함 
  - 중간의 요소가 삭제되거나 삽입되는 경우도 나머지 요소에 대한 조정하는 코드를 구현해야 함.

  - ArrayList 클래스는 자바에서 제공되는 객체 배열이 구현된 클래스 
  - 여러 메서드와 속성 등을 사용하여 객체 배열을 편리하게 관리할 수 있음
  - 가장 많이 사용하는 객체 배열 클래스 

## ArrayList 클래스 주요 메서드 
  - boolean add(E e) 요소 하나를 배열에 추가합니다. E는 요소의 자료형을 의미함.
  - int size() - 배열에 추가된 요소 전체 개수를 반환함.
  - E get(int index) - 배열의 index 위치에 있는 요소 값을 반환 
  - E remove(int index) - 배열의 index 위치에 있는 요소 값을 제거하고 그 값을 반환함.
  - boolean isEmpty() - 배열이 비어있는지 확인   
  
## ArrayList 클래스 사용하기 
  - ArrayList<E> 배열이름 = new ArrayList<E>();
  - 사용할 객체를 E 위치에 넣고 ArrayList 메서드를 활용하여 추가하거나 참조할 수 있음.


8. 상속과 다형성
## 상속이란?
  - 클래스를 정의할 때 이미 구현된 클래스를 상속(inheritance) 받아서 속성이나 기능이 확장되는 클래스를 구현함.
  - 상속하는 클래스 : 상위 클래스, parent class, base class, super class
  - 상속 받는 클래스 : 하위 클래스, child class, derived class, subclass
  - 클래스 상속 문법
    - class B extends A {}

## 상속이란?
  - 상위 클래스는 하위 클래스 보다 일반적인 의미를 가짐 
  - 하위 클래스는 상위 클래스 보다 구체적인 의미를 가짐 
  - 포유류 <- 사람
    - class Mammal{}
    - class Human extends Mammal {}
  - extends 뒤에는 단 하나의 class만 사용할 수 있음
  - 자바는 single inheritance만을 지원 함.

## 상속을 활용한 고객관리 프로그램 
  - 고객의 정보를 활용하여 고객 맞춤 서비스를 구현 
  - 고객의 등급에 따라 차별화 된 할인율과 포인트를 지급 
  - 등급에 따른 클래스를 따로 구현하는 것이 아닌 일반적인 클래스를 먼저 구현하고 그 보다 기능이 많은
    클래스는 상속을 활용하여 구현함.
    - Customer <- VIP Customer 
               <- Gold Customer 

## 새로운 고객 등급이 필요한 경우 
  - 단골고객에 대한 혜택이 필요함
  - 우수 고객을 관리하기 위해 다음과 같은 혜택을 줌
    - 고객 등급 : VIP 
	- 제품 구매 할인율 : 10% 
	- 보너스 포인트 : 5% 
	- 담당 전문 상담원 배정 
	
	
## 접근 제한자 가시성 

             | 외부 클래스 | 하위 클래스 | 동일 패키지 | 내부 클래스 
   ----------|----------|----------|---------------------		 
   public    | O        | O        | O        | O
   ----------|----------|----------|----------|----------
   protected | X        | O        | O        | O
   ----------|----------|----------|----------|----------
   선언되지 않음 | X        | X        | O        | O
   (default) |          |          |          |
   ----------|----------|----------|----------|----------
   private   | X        | X        | X        | O
   ----------|----------|----------|----------|----------   
   
## 상속에서의 메모리 상태 
  - 상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성 됨.
    - public class VIPCustomer extends Customer {}
	  - ① Customer() 생성자 호출 - Customer 클래스의 멤버 변수가 메모리에 생성됨 
	  - ② VIPCustomer() 생성자 호출 - VIPCustomer 클래스의 멤버변수가 메모리에 생성됨

## 상위 클래스로의 묵시적 형변환(업캐스팅)
  - 상위 클래스형으로 변수를 선언하고 하위 클래스 인스턴스를 생성할 수 있음
  - 하위 클래스는 상위 클래스 타입을 내포하고 있으므로 상위 클래스로 묵시적 형변환이 가능 함 
    - Customer vc = new VIPCustomer();
	
## 형 변환에서 메모리 
  - Customer vc = new VIPCustomer(); 에서 vc가 가리키는 것은?
  - VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성 되었지만 타입이 Customer이므로 접근할 수 있는 변수나
    메서드는 Customer 변수와 메서드임

## Java Decompile
  - cd workspace (작업디렉토리)
  - cd Chapter8\bin
  - javap -verbose inheritance.VIPCustomer > a.out 


## 메서드 오버라이딩(overrriding) 
  - 상위 클래스에 정의된 메서드 중 하위 클래스와 기능이 맞지 않거나 추가 기능이 필요한 경우 같은 이름과 매개변수로 하위 클래스에서
    재정의 함.
  - VIPCustomer 클래스의 calcPrice() 메서드 재정의 
    - public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	  }
	- 보너스 포인트 적립하고 할인률을 적용한 가격을 반환 
	
## 묵시적 형변환과 재정의 된 메서드 호출
  - Customer vc = new VIPCustomer();
    vc.calcPrice(10000);

  - 위 코드에서 calcPrice() 메서드는 어느 메서드가 호출 될 것인가? 재정의 된 메서드 호출 

## 가상 메서드(virtual method)
  - 프로그램에서 어떤 객체의 변수나 메서드의 참조는 그 타입에 따라 이루어짐. 가상 메서드의 경우는 타입과 상관없이 실제 생성된 
    인스턴스의 메서드가 호출 되는 원리 
	- Customer vc = new VIPCustomer();
	  vc.calcPrice(10000);
	- vc의 타입은 Customer 이지만, 실제 생성된 인스턴스인 VIPCustomer 클래스의 calcPrice() 메서다가 호출 됨. 

## 다형성(polymorphism)
  - 하나의 코드가 여러가지 자료형으로 구현되어 실행되는 것 
  - 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나 
  - 객체지향 프로그래밍의 유연성, 재활용성, 유지보수성에 기본이 되는 특징임.

## 다형성 구현 하기 
  - 하나의 클래스를 상속 받은 여러 클래스가 있는 경우 
  - 각 클래스마다 같은 이름의 서로 다른 메서드를 재정의 함 
  - 상위 클래스 타입으로 선언된 하나의 변수가 여러 인스턴스에 대입되어 다양한 구현이 실행될 수 있음. 
  
## 다형성 활용하기 
  - 일반 고객과 VIP 고객의 중간 등급의 고객을 생성 
  - 5명의 고객을 ArrayList에 생성하여 저장한 다음 각 고객이 물건을 샀을 때의 가격과 보너스 포인트를 개산 함. 

## 상속을 언제 사용할까?
  - 여러 클래스를 생성하지 않고 하나의 클래스에 공통적인 요소를 모으고 나머지 클래스는 이를 상속받은 다음 필요한 특성과 메서드를
    구현하는 방법
  - 하나의 클래스에 여러 특성을 한꺼번에 구현하는 경우 많은 코드 내에 많은 if문이 생길수 있음 
  
  - IA-A 관계(is a relationship : inheritance)
    - 일반적인(general) 개념과 구체적인(specific) 개념과의 관계 
	- 상위 클래스 : 일반적인 개념 클래스(예:포유류) 
	- 하위 클래스 : 구체적인 개념 클래스(예:사람, 원숭이, 고래, ...) 
	- 단순히 코드를 재사용하는 목적으로 사용하지 않음 
  - HAS-A 관계(composition or aggregation) : 한 클래스가 다른 클래스를 소유한 관계 
    - 코드 재사용의 한 방법 
	- Student가 Subject를 포함한 관계 

## 다운 캐스팅 - instanceof
  - 하위 클래스가 상위 클래스로 형 변환 되는 것은 묵시적으로 이루어 짐 
  - 다시 원래 자료 형인 하위 클래스로 형 변환 하려면 명시적으로 다운 캐스팅을 해야 함.
    이때 원래 인스턴스의 탕비을 체크하는 예약어가 instanceof 임
    - Animal hAnimal = new Human();
	  if(hAnimal instanceof Human) {   // hAnimal 인스턴사 자료형이 Human형 이라면
		  Human human = (Human)hAnimal; // 인스턴스 hAnimal을 Human형으로 다운 캐스팅
	  }

9. 추상 클래스 
    - 상속을 하기위해 사용되는 클래스 
	
## 추상 클래스란? (abstract class) 
  - 추상 메서드를 포함하고 있는 클래스 
  - 추상 메서드는 구현코드 없이 메서드의 선언만 있음 
    - 예) abstract int add(int x, int y); //선언만 있는 추상 메서드 
	      int add(int x, int y) {} // {} 부분이 구현 내용임, 추상 메서드 아님.
  - abstract 예약어 사용 
  - 추상 클래스는 new(인스턴스화) 할 수 없음 
    - cf) concreate class 
  - 상속을 하기위해 사용	
	
## 추상 클래스 구현 하기 
  - public abstract class Computer {
		public abstract void display();
		public abstract void typing();
		...
	}
  - 메서드에 구현코드가 없으면 abstract로 선언해야 함.
  	- public abstract void display();
	- public void display() {}; // 추상 메서드 아님. {}로 인해 구현부는 있으나 구현코드가 없는거임.
  - abstract로 선언된 메서드를 가진 클래스는 abstract로 선언 함.
  
  - 만약 모든 메서드가 구현코드가 있지만, 클래스가 abstract로 선언하여 추상 클래스로 사용 됨 -> new 할 수 없음  
    - 일반 클래스를 추상 클래스로 변경하여 상속용으로 사용하는 경우가 있음.

## 추상 클래스와 템플릿 메서드 
  - 템플릿 메서드 - 추상 메서드나 구현된 메서드를 활용하여 전체 기능의 흐름(시나리오)을 정의하는 메서드 
                 final로 선언하면 하위 클래스에 재정의 할 수 없음 
  - 프레임 워크에서 많이 사용되는 설계 패턴 
  - 추상 클래스로 선언된 상위 클래스에 템플릿 메서드를 활용하여 전체적인 흐름을 정의하고 하위 클래스에서 다르게 
    구현되어야 하는 부분은 추상 메서드로 선언해서 하위 클래스가 구현하도록 함.

## 템플릿 메서드 구현 예약어
  - Player	
  
## PlayLevel 클래스 
  - public abstract class PlayerLevel {
		public abstract void run();
		public abstract void jump();
		public abstract void turn();
		public abstract void showLevelMessage();
		
		final public void go(int count) {
			run();
			for(int i=0; i < count; i++) {
				jump();
			}
			turn();
		}
    }		
		
  - 각 레벨마다 run(), jump(), turn() 기능은 다르게 구현되어야 하므로 추상 메서드로 선언 
  - final로 선언된 go() 메서드에서 각 순서와 반복 횟수를 구현함(템플릿 메서드)  

## final 예약어 
  - final 변수는 값이 변경될 수 없는 상수임 
    - public static final double PI=3.14;
  - final 변수는 오직 한 번만 값을 할당할 수 있음.
  - final 메서드는 하위 클래스에서 재정의 (overriding) 할 수 없음 
  - final 클래스는 더 이상 상속되지 않음 
    - 예) java의 String 클래스 
	
## 여러 자바 파일에서 공유하는 상수 값 정의하기 
  - 프로젝트 구현시 여러 파일에서 공유해야 하는 상수 값은 하나의 파일에 선언하여 사용하면 편리함.
  - public class Define {
		public static final int MIN = 1;
		public static final int MAX = 99999;
		public static final int ENG = 1001;
		public static final int MATH = 2001;
		public static final int PI = 3.14;
		public static final String GOOD_MORNING = "Goood Morning!";
		
  - public class UsingDefine {
		public static vood main(String[] args) {
			system.out.println(Define.Good_MORNING);
			system.out.println("최솟값은 " + Define.MIN + "입니다.");
			system.out.println("최댓값은 " + Define.MAX + "입니다.");			
			system.out.println("수학 과목 코드 값은 " + Define.MATH + "입니다.");
			system.out.println("영어 과목 코드 값은 " + Define.ENG + "입니다.");
		
			
10. 인터페이스(interface)
## 인터페이스 란?
  - 모든 메서드가 추상 메서드(abstract method)로 이루어진 클래스 
  - 형식적인 선언만 있고 구현은 없음
    - interface 인터페이스_이름 {
		public static final float pi = 3.14;
		public void add();
	  }
  - 인터페이스에 선언된 모든 메서드는 public abstract로 추상 메서드 
  - 인터페이스에 선언된 모든 변수는 public static final 로 상수 
  - 컴파일시 컴파일러가 자동으로 붙여줌. 
  - 인터페이스는 client code의 spec 이다.  

## 클래스에서 인터페이스 구현하기 
  - Calc 인터페이스를 Calculator 클래스에서 구현 
  - Calc를 implements 하여 Calculator 클래스를 만들고 모든 추상 메서드를 구현하지 않으면 Calculator는 추상 클래스가 됨.
  - CompleteCalc 클래스가 Calculator를 상속 받은 후 모든 메서드를 구현 
  - CompleteCalc는 생성가능한 클래스 
    - [Calc 추상 Class] <···(점선)implement··· [Calculator : 추상 or 일반 Class] <---(실선)상속--- [CompleteCalc]
      ※ Calc의 모든 추상 메서드를 구현하지 않으면 Calculator는 추상 클래스가 됨.

## 용어 정의
  - java 에서 interface의 implements 는 타입상속이라 하고 
    extends에 의한 상속은 구현상속이라고 함.   
  - Calc(인터페이스), Calculator(추상 class), CompleteCalc(클래스)
    - Calc calc = new CompleteClac();   // 타입 상속   

## 인터페이스 구현과 형 변환
  - 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 할 수 있음
  - 상속에서의 형 변환과 동일한 의미 
  - 단, 클래스 상속과 달리 구현코드가 없기 때문에 인터페이스를 구현할 수 있음 
  - 형 변환시 사용할 수 있는 메서드는 인터페이스에 선언된 메서드만 사용할 수 있음. 
  - Calc calc = new CompleteCalc();  
    - CompleteCalc 가 Calc형으로 대입된 경우 사용할 있는 메서드.

## 인터페이스와 다형성 
  - 인터페이스는 "Client Code"와 서비스를 제공하는 "객체" 사이의 약속이다.
  - 어떤 객체가 어떤 interface 타입이라 함은 그 interface가 제공하는 메서드를 구현했다는 의미임. -> 타입 상속
  - Client는 어떻게 구현되었는지 상관없이 interface의 정의만을 보고 사용할 수 있음 (ex : JDBC)
  - 다양한 구현이 필요한 인터페이스를 설계하는 일은 매우 중요한 일임.  

## 왜 인터페이스를 사용하는가?
  - [UserInfoWeb] ---> uses ----> IUserInfoDao <··· implements ··· oracleDao
                                               <··· implements ··· mysqlDao
                                               <··· implements ··· mssqlDao
  - UserInfoWeb 은 IUserInfoDao에 정의된 메소드 명세만 보고 Dao를 사용할 수 있고, Dao 클래스들은 
    IUserInfoDao에 정의된 메소드를 구현할 책임이 있다.

  - 설계를 할때 사용함.
  
## JDBC 
  - Connection, Statement는 interface로 작성되어 있음. 이름 각 DB 회사(oracle, mysql 등)에서 구현하여 
    .jar 형태로 제공하고 있음.  
  - 개발자는 interface를 참조하여 DB와 연결함. interface 구현은 DB회사.

## 인터페이스의 요소 
  - 상수 : 모든 변수는 상수로 변환 됨
  - 추상 메서드 : 모든 메서드는 추상메서드로 구성 
  - Java 8 부터 추가된 기능 
    - 디폴트 메서드 : 기본 구현을 가지는 메서드, 구현 클래스에서 재정의 할 수 있음 
    - 정적(static) 메서드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 사용할 수 있는 메서드 
    - private 메서드 : 인터페이스를 구현한 클래스에서 사용하거나 재정의 할 수 없음. 인터페이스 내부에서만 기능을 제공하기 위해 
                   구현하는 메서드   

## 디폴트 메서드 재정의 
  - Calc 인터페이스에 디폴트 메서드 정의
    - public interface Calc {
		...
		default void description() {
			System.out.println("정수 계산기를 구현합니다.");
		}
	  } 
  - CompleteCalc에서 재정의 하기 
    public class CompleteCalc extends Calculator {
		...
		@Override 
		publci void description() {
		super.description();
	}
	※ 디폴트 메서드 description()을 CompleteCalc 클래스에 서 원하는 기능으로 재정의 

## private 메서드 
  - 인터페이스 내부에 private 혹은 private static으로 선언한 메서드 구현 
  - private static은 정적 메서드에서 사용 가능
  - private으로 선언한 메서드는 default 메서드에서 사용하고 private static로 선언한 메서드는 static 메서드에서 사용.
  
## 두 개의 인터페이스 구현하기 
  - [Buy interface]  <··· implements ··· [Customer Class - 실제구현 클래스]
    [Sell interface] <··· implements 

## 두 인터페이스를 구현한 클래스 
  - public class Customer implements Buy, Sell {
		@Override 
		public void sell() {
			System.out.println("구매하기");
		}
		
		@Override
		public  void buy() {
			System.out.println("판매하기");
		}
	}

## 두 인터페이스의 디폴트 메서드가 중복되는 경우 
  - 구현한 클래스에서 중복된 디폴트 메서드를 재정의 함.	
  
## 인터페이스 상속 
  - 인터페이스 간에도 상속이 가능 
  - 구현코드의 상속이 아니므로 형 상속(type inheritance)라고 함.
  
  - [X interface] <--- extends -- -- [MyInterface interface, myMethod()] <··· implements ··· [MyClass class]
                                 |
    [Y interface] <--- extends --
	
  - public interface MyInterface extends X, Y {
		void myMethod();
	}

## 인터페이스 구현과 클래스 상속 함께 사용하기 
  - [Shelf Class]     <--- extends ------ --- [BookShelf Class]
                                         | 
	[Queue interface] <··· implements ···
	
  - public class BookShelf extends Shelf implements Quedu {
  
		// 배열에 요소 추가
		@Override 
		public void enQueue(String title) {
			shelf.add(title);
		}
		
		// 맨 처음 요소를 배열에서 삭제하고 반환
		@Override 
		public String deQueue(String title) {
			return shelf.remove(0);
		}
		
		// 배열 요소 개수 변환 
		@Override 
		public int getSize() {
			return getCount();
		}
	}
  - 실제 프레임워크(스프링, 안드로이드)를 사용하면 클래스를 상속받고 여러 인터페이스를 구현하는 경우가 종종 있음
  


11. 기본 클래스  
## java.lang 패키지 
  - 프로그래밍시 import 하지 않아도 자동으로 import 됨 
  - import java.lang.*; 문장이 추가됨.
  - 많이 사용하는 기본 클래스들이 속한 패키지 
  - String, Integer, System 등 

## Object 클래스 
  - 모든 클래스의 최상위 클래스 
  - java.lang.Object 클래스 
  - 모든 클래스는 Object 클래스에서 상속 받음
  - 모든 클래스는 Object 클래스의 메서드를 사용할 수 있음 
  - 모든 클래스는 Object 클래스의 메서드 중 일부는 재정의 할 수 있음(final로 선언된 메서드는 재정의 할 수 없음)
  - 컴파일러가 extends Object를 추가함.

## Object 클래스 메서드 
  - String toString() - 객체를 문자열로 표현하여 반환함. 재정의하여 객체에 대한 설명이나 특정 멤버 변수 값을 반환 
  - boolean equals(Object obj) - 두 인스턴스가 동일한지 여부를 반환함. 재정의하여 논리적으로 동일한 인스턴스임을
                                 정의할 수 있음.
  - int hashCode() - 객체의 해시 코드 값을 반환함.
  - Object clone() - 객체를 복제하여 동일한 멤버 변수 값을 가진 새로운 인스턴스를 생성함.
  - Class getClass() - 객체의 Class 클래스를 반환함. 
  - void finalize() - 인스턴스가 힙 메모리에서 제거될 때 가비지 컬레터(GC)에 의해 호출되는 메서드임. 
                    - 네트워크 연결 해제, 열려 있는 파일 스트림 해제 등을 구현함.
  - void wait() - 멀티스레드 프로그램에서 사용하는 메서드 임. 스레드를 '기다리는 상태'(non runnable)로 만듬.
  - void notify() - wait() 메서드에 의해 기다리고 있는 스레드(nonrunnable 상태를 실행 가능한 상태(runnable)로 가져 옴.
  
## toString() 메서드 
  - Object 클래스의 메서드 
  - 객체의 정보를 String으로 바꾸어서 사용할 때 많이 쓰임 
  - String이나 Integer 클래스에는 이미 재정의 되어 있음
  - String은 문자열 반환 
  - Integer는 정수값 반환  


## String과 Integer의 toString() 메서드 
  - toString() 메서드가 재정의 되어 있음 
  - String은 문자열 반환 
  - Integer는 정수 값 반환 
  - String str = new String("test");
	System.out.println(str);  // test 출력
	Integer i1 = new Integer(100);
	System.out.println(i1);	  // 100 출력 

## equals() 메서드 
  - 두 인스턴스이 주소 값을 비교하여 true/false를 반환 
  - 재정의 하여 두 인스턴스가 논리적으로 동일함의 여부를 반환 
  - 같은 학번의 학생인 경우 여러 인스턴스의 주소값은 다르지만, 같은 학생으로 처리해야 학점이나 정보 산출 문제가 
    생기지 않으므로 이런 경우 equals() 메서드를 재정의 함. 
  - Student studentLee = new Student(100, "이상원");
    Student studentLee2 = studentLee; // 주소 복사   

## String과 Integer의 equals() 메서드 
  - String은 같은 문자열의 경우 true를 반환   
  - Integer는 정수 값이 같은 경우 true를 반환 
  
## hashCode() 메서드 
  - hash : 정보를 저장, 검색하기 위해 사용 하는 자료 구조 
  - 자료의 특정 값(키 값)에 대해 저장 위치를 반환해 주는 해쉬 함수를 사용함 
    - index = hash(key)
      - index - 저장위치, 주소 값
      - hash() - 해시 함수 
      - key - 객체 정보 	  
  - 해시 함수는 어떤 정보인가에 따라 다르게 구현 됨 
  - hashCode() 메서드는 인스턴스의 저장 주소를 반환함 
  - 힙 메모리에 인스턴스가 저장되는 방식이 hash   
  
  - hashCode()의 반환 값 : 자바 가상 머신이 저장한 인스턴스의 주소값을 10진수로 나타냄 
  - 서로 다른 메모리의 두 인스턴스가 같다면???
    - 재정의 된 equals() 메서드의 값이 true 
	- 동일한 hashCode() 반환값을 가져야 함.
  - 논리적으로 동일함을 위해 equals() 메서드를 재정의 하였다면 hashCode() 메서드로 재정의 하여
    동일한 값이 반환 되도록 함. 
	※ equals() 메서드를 재정의 하였다면 hashCode()값도 동일하게 만들어야 함
  - String 클래스 : 동일한 문자열 인스턴스에 대해 동일한 정수가 반환 됨 
  - Integer 클래스 : 동일한 정수값의 인스턴스에 대해 같은 정수값이 반환 됨.
  
## clone() 메서드 
  - 객체의 원본 복제하는데 사용하는 메서드 
  - 원본을 유지해 놓고 복사본을 사용할 때 
  - 기본 틀(prototype)을 두고 복잡한 생성과정을 반복하지 않고 복제 
  - clone() 메서드를 사용하면 객체의 정보(멤버변수 값)가 같은 인스턴스가 또 생성되는 것이므로 객체 지향 
    프로그램의 정보은닉, 객체 보호의 관점에서 위배될 수 있음.
  - 객체의 clone() 메서드 사용을 허용한다는 의미로 cloneable 인터페이스를 명시해 줌
    - class Circle implements Cloneable { // ※ 객체를 복제해도 된다는 의미로 Cloneable 인터페이스를 함께 선언 
		Point point;
		int radius;
      }

## String 클래스 
  - String을 선언하는 두 가지 방법 
    - String str1 = new String("abc"); // 생성자의 매개변수로 문자열 생성 
	- String str2 = "test";            // 문자열 상수를 가리키는 방식 
  - 힙 메모리에 인스턴스로 생성되는 경우와 상수 풀(constant pool)에 있는 주소를 참조하는 방법 두가지 
    - str1 -------------------> "abc" (힙메모리)
	- str2 -------------------> "test" (상수 풀) <----------------- str3
	  - 상수 풀의 문자열을 참조하면 모든 문자열이 같은 주소를 가리킴 

## String 클래스로 문자열 연결 
  - 한번 생성된 String 값(무자열)은 불변(immutable)
  - 두 개의 문자열을 연결하면 새로운 인스턴스가 생성됨
  - 문자열 연결을 계속하면 메모리에 garbage가 많이 생길 수 있음.
    - 이를 해결하기 위해 StringBuilder, StringBuffer 사용함.
   
  - String javaStr = new String("java");
	String androidStr = new String("android");
	System.out.println(javaStr);
	System.out.println("처음 문자열 주소 값: " + System.identityHashCode(javaStr));
	
	javaStr = javaStr.concat(android); // 문자열 javaStr와 문자열 androidStr를 연결하여 javaStr에 대입 
	
    - javaStr --- X ---> "java"                                android ------> "android" 
	          ---------> "javaaddroid" (새로 생성된 문자열을 가리킴)


## StringBuilder, StringBuffer 사용하기 
  - 내부적으로 가변적인 char[] 배열을 가지고 있는 클래스 
  - 문자열을 여러 번 연결하거나 변경할 때 사용하면 유용함.
  - 매번 새로 생성하지 않고 기존 배열을 변경하므로 garbage가 생기지 않음 
  
  - StringBuffer는 멀티 쓰레드 프로그래밍에서 동기화(synchronization)을 보장 
  - 단일 쓰레드 프로그램에서는 StringBuilder를 사용하기를 권장 
  - toString() 메서드로 String 반환 

## Wrapper 클래스 
 - 기본 자료형(primitive data type)에 대한 클래스 
 - boolean - Boolean
   byte    - Byte
   char    - Character
   short   - Short 
   int     - Integer 
   long    - Long 
   float   - Float 
   double  - Double

## 오토 박싱(autoboxing)과 언박싱(unboxing)
  - Integer는 객체이고, int는 4바이트 기본 자료형임
  - 두개의 자료를 같이 연산할 때 자동으로 변환이 일어남 
  - Integer num1 = new Integer(100);
    int num2 = 200;
	int sum = num1 + num2; // num.intValue()로 변환(언박싱)
	Integer num3 = num2;   // Integer.valueOf(num2)로 변환(오토박싱) 

## Class 클래스 
  - 자바의 모든 클래스와 인터페이스는 컴파일후 class 파일로 생성됨
  - class 파일에는 객체의 정보(멤버변수, 메서드, 생성자동)가 포함되어 있음 
  - Class 클래스는 컴파일된 class 파일에서 객체의 정보를 가져올 수 있음.

## Class 클래스 오기 
  1. Object 클래스의 getClass() 메서드 사용하기 
    - String s = new String();
      Class c = s.getClass(); // getClass() 메서드이 반환형은 Class 
  2. 클래스 파일 이름을 Class 변수에 직접 대입하기 
    - Class c = String.Class;
  3. Class.forName("클래스 이름") 메서드 사용하기 
    - Class c = Class.forName("java.lang.String");

## Class 클래스로 정보 가져오기 
  - reflection 프로그래밍 - Class 클래스를 이용하여 클래스의 정보(생성자, 멤버변수, 메서드)를 가져오고 이를 활용하며 
                         인스턴스를 생성하고, 메서드를 호출하는 등의 프로그래밍 방식 
  - 로컬 메모리에 객체가 없어서 객체의 데이터 타입을 직접 알 수 없는 경우(원격 객체가 있는 경우 등) 객체 정보만을 이용하여
    프로그래밍 할 수 있음 
  - Constructor, Method, Filed 등 java.lang.reflect 패키지에 있는 클래스들을 활용하여 프로그래밍 
  - 일반적으로 자료형을 알 수 있는 경우에는 사용하지 않음.

## Class.forName() 메서드로 동적 로딩 하기 
  - 동적 로딩이란? 컴파일 시에 데이터 타입이 모두 binding 되어 자료형이 로딩되는 것(static loading)이 아니라 실행중에 
                데이터 타입을 알고 binding 되는 방식 
  - 프로그래밍 할 때는 어떤 클래스를 사용할지 모를 때 변수로 처리하고 실행될 때 해당 변수에 대입된 값의 클래스가 실행될 수 있도록 
    Class 클래스에서 제공하는 static 메서드 
  - 실행시에 로딩되므로 경우에 따라 다른 클래스가 사용될수 있어 유용함. 
  - 컴파일 타임에 체크할 수 없으므로 해당 문자열에 대한 클래스가 없는 경우 예외(ClassNotFoundException)이 발생할 수 있음.
    - String className = "classex.Person";
      Class pClass = Class.forName(className);
	  
12. 컬렉션 프레임워크 
## 제네릭(Generic) 프로그래밍 
  - 변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형을 변환 될 수 있도록 프로그래밍 하는 방식
  - 실제 사용되는 참조 자료형으로의 변환은 컴파일러가 검증하므로 안정적인 프로그래밍 방식 
  - 컬렉션 프레임워크에서 많이 사용되고 있음.

## 제네릭 클래스 정의 하기 
  - 여러 참조 자료형으로 대체 될 수 있는 부분을 하나의 문자로 표현 
  - 이 문자를 자료형 매개변수라고 함.
    - public class GenericPrinter<T> {
		private T material;
		
		public void setMaterial(T material) {
			this.material = material;
		}
		
		public T getMaterial() {
			return material;
		}
	 }

## 자료형 매개변수 T
  - type의 의미로 T를 많이 사용 함
  - <T>에서 <>는 다이아몬드 연산자라고 함 
  - static 키워드는 T에 사용할 수 없음 
  
  - ArrayList<String> list = new ArrayList<>();
    - 다이아몬드 연산자 내부에서 자료형은 생략 가능 함.
  - 제네릭에서 자료형 추론(자바10 부터) 
    - ArrayList<String> list = new ArrayList<String>(); ---> var list = new ArrayList<String>();

## 제네릭 클래스 사용하기 
  - GenericPrinter<Powder> PowderPrinter = new GenericPrinter<Powder>();
    powderPrintr.setMaterial(new Powder());
	Powder powder = powderPrinter.getMatterial(); // 명시적 형 변환을 하지 않음
	
  - T 로 정의한 부분에 사용할 참조 자료형을 넣어서 클래스 생성
  - getMaterial() 메서드가 호출 될 때 따라 강제 형변환을 하지 않아도 됨.
  - GenericPrinter<Powder> - 제네릭 자료형(Generic type), 매개변수화된 자료형(parameterized type)
    Powder - 대입된 자료형 

## 제네릭에서 대입된 자료형을 명시하지 않는 경우 
  - GenericPrinter<Powder>와 같이 사용할 자료형(Powder)를 명시해야 함 
  - 자료형을 명시하지 않고 사용할 수 있음 이런 경우 지료형을 명시하라는 경고 표시가 나타남.
  - 반환 형에 따라 강제 형 변화을 해야 함. 
  
## <T extends 클래스> 
  - T가 사용될 클래스를 제한하기 위해 사용
  - Material 에서 상속받지 않은 Water와 같은 클래스는 프린터 재료로 사용할 수 없음 
  - Material에 정의된 메서드를 공유할 수 있음. 

## 제네릭 메서드 활용하기 
  - 메서드의 매개변수를 자료형 매개변수로 사용하는 경우 자료형 매개 변수가 하나 이상인 경우
  - 제네릭 메서드의 일반 형식 
    - public <자료형 매개변수> 반환형 메서드 이름<자료형 매개변수 ...) {} 
	
## 자효형 매개변수가 두 개인 경우 
 - public class Point<T, V> {
	T x;
	V y;
	
	Point(T x, V y) {
		this.x = x;
		this.y = y;
	}
	
	public T getX() {
		return x;
	}
	
	public V getY() {
		return y;
	}
   }


## Array (배열)
  - 같은 형의 데이터 타입을 메모리에 저장하는 선형적 자료구조.
  - 논리적 구조와 물리적 구조가 동일함
  - 정의할때 고정된 크기를 정의하고 공간이 없는 경우 새로운 배열을 생성해 이동 시킨다.
  - JDK
    - ArrayList 
	- Vector 

## Linked List  
  - [Data + Link] ---> [Data + Link] ---> [Data + Link]
    - [Data + Link] - 노드(Node) 
    - Link에 다음 노드의 주소를 저장하고 있음.
  - 논리적 구조와 물리적 구조가 다름
  - 필요할 때마다 메모리 할당을 받고 이전 Node에 주소를 지정
  - 배열의 단점을 보완 - 하나를 삭제하면 배열의 경우 뒤에 있는 요소의 이동이 발생하지만 링크드 리스트에서는 주소의 변경으로 가능 
  - insert, delete 시 배열보다 효율적 임.
  - 배열은 인덱스 연산이 가능하나 링크드 리스트는 연산이 불가하여 맨 처음부터 찾아서 가야함.
  - JDK
    - LinkedList
	
## Stack
  - 일반적인 의미 - 쌓다, 더미 
  - Stack 과 Queue 는 배열 또는 링크드 리스트로 구현 가능.
  - 선형 자료구조
  - LIFO(Last In First Out)
  - 바둑의 무르기 와 같은 기능들을
  - Peek?
    - 스택의 맨 위에 있는 원소를 반환 
	- 스택에서 제거하지 않으며 일종의 get() 임

  - JDK 
    - Stack 
  
## Queue 
  - enQue(Push), deQue(Pop) 
  - FIFO(First In First Out) - fron ---- rear
  - 상담원의 Call 처리, 선착순, 대기열
  - ArrayList 로 구현 
    - add() - 끝에 삽입 
    - remove(0) - 앞에서 꺼내옴(Queue)	
  - JDK 
    - ArrayList 
    - Vector 
    - Linked List 	
	
## Tree 
  - Binary Search Tree를 왜 쓰나요?
    - 자료의 검색
  - Binary Tree - 자식이 2개씩 있는 Tree
    - parent node, left child node, right child node 
  - Binary Search Tree(BST)
    - 나를 중심으로 left child node는 나보다 작고 right child node는 나보다 크다.
    - 값의 중복을 허용하지 않는다. 
	
  - Balance를 맞추기 위해 고안된 Tree - AVL Tree, Red black 	
  - Tree 정렬 
    - in-order Travers : Left -> 나 -> Right(오름차순), Right -> 나 -> Left(내림차순) 

## Binary Search Tree의 특성 
  - 유일한 키 값.
  - 루트 노드의 키 값 기준 
  - 왼쪽 서브트리 키 값, 오른쪽 서브트리 키 값 
  - JDK 
    - Treeset, TreeMap(Red-Black Tree) 

## Hashing(해싱)
  - 산술 연산을 이용한 검색 방식 
  - index = h(key)
    - index - 검색 자료의 주소
	- key   - 검색 키
	- h()   - 해싱 함수 
  - JDK 
    - HashMap, HashSet 

## 컬렉션 프레임워크 
  - 프로그램 구현에 필요한 자료구조(Data Structure)를 구현해 놓은 라이브러리 
  - java.util 패키지에 구현되어 있음 
  - 개발에 소요되는 시간을 절약하면서 최적화된 알고리즘을 사용할 수 있음
  - 여러 인터페이스와 구현 클래스 사용 방법을 이해해야 함.
  
  - Collection - 자료구조
    - List - 선형자료 구조 - 앞뒤의 데이터가 1개인 구조 - 배열, 링크드리스트, 스택, 큐 - 순서가 있는 자료 구조 - 요소 중복 가능  
	  - ArrayList, Vector, LinkedList  
    - Set  - 집합의 개념, 요소가 중복 불허용, 유일한 데이터 관리, 순서 상관 없음	
	  - HashSet, TreeSet
  - Map - Key, Value 구조	
    - HashTable, HashMap, TreeMap 
	
## Collection 인터페이스
  - 하나의 객체를 관리하기 위한 메서드가 선언된 인터페이스 
  - 하위 List와 Set 인터페이스가 있음 
  - 여러 클래스들이 Collection 인터페이스를 구현함 
    - List 인터페이스 - 순서가 있는 자료 관리, 중복 허용. 이 인터페이스를 구현한 클래스는 ArrayList, Vector, LinkedList, Stack, Queue 등이 있음  
    - Set 인터페이스 - 순서가 정해지지 않음. 중복을 허용하지 않음. 이 인터페이스를 구현한 클래스는 HashSet, TreeSet 등이 있음  	

  - Collection 인터페이스에 선언된 주요 메서드 
    - boolean add(E e) - Collection에 객체를 추가 
	- void clear() - Collection의 모든 객체를 제거
	- iterator<E> iterator - Collection을 순환할 반복자(iterator)를 반환 
	- boolean remove(Object o) - Collection 매개변수에 해당하는 인스턴스가 존재하면 제거 
	- int size() - Collection에 있는 요소의 개수를 반환함. 
	
	
## ArrayList 와 Vector 
  - 객체 배열을 구현한 클래스
  - Vector는 자바2 부터 제공된 클래스 
  - 멀티 쓰레드 상태에서 리소스에 대한 동기화가 필요한 경우 Vector를 사용 
  - 일반적으로 ArrayList를 더 많이 사용 함 
  - ArrayList에 동기화 기능이 추가 되어야 하는 경우 
    - Collections.synchronizedList(new ArrayList<String>());
  - 동기화(synchronization): 두 개의 쓰레드가 동시에 하나의 리소스에 접근할 떄 순서를 맞추어서 데이터에 오류가 발생하지 않도록 함.
    
  
## Stack과 Queue 
  - Stack과 Queue의 기능은 구현된 클래스가 있지만 ArrayList나 LinkedList를 활용하여서 사용할 수도 있음 	
  - Stack : Last In First Out(LIFO) 
    - 맨 마지막에 추가 된 요소가 먼저 꺼내지는 자료구조. 게임의 무르기 기능, 최근 자료 추출 등에서 사용 
    - 추가(push), 삭제(pop)
	
## Iterator 사용하여 순회하기 
  - Collection의 개체를 순회하는 인터페이스 
  - iterator() 메서드 호출 
    - Iterator ir = memberArrayList.iterator();
  - 선언된 메서드 
    - boolean hasNext() - 이후에 요소가 더 있는지를 체크하는 메서드이며, 요소가 있다면 true를 반환함.
    - E next() - 다음에 있는 요소를 반환함.
	
## Set 인터페이스
  - Collection 하위의 인터페이스 
  - 중복을 허용하지 않음
  - 아이디, 주민번호, 사번 등 유일한 값이나 객체를 관리할 때 사용 
  - List는 순서기반의 인터페이스지만, Set은 순서가 없음 
  - 저장된 순서와 출력순서는 다를 수 있음 
  - get(i) 메서드가 제공되지 않음  

## TreeSet 클래스 
  - 객체의 정렬에 사용되는 클래스 
  - 중복을 허용하지 않으면서 오름차순이나 내림차순으로 객체를 정렬 함
  - 내부적으로 이진 검색 트리(binary search tree)로 구현되어 있음 
  - 이진 검색 트리에 자료가 저장될 때 비교하여 저장될 위치를 정함 
  - 객체 비교를 위해 Comparable이나 Comparator 인터페이스를 구현 해야 함.
  

13. 내부 클래스 요약 
  - 인스턴스 내부 클래스
    - 구현 위치 - 외부 클래스 멤버 변수와 동일 
	- 사용할 수 있는 외부 클래스 변수 - 외부 인스턴스 변수, 외부 전역변수
	- 생성 방법 - 외부 클래스를 먼저 만든 후 내부 클래스 생성 
  - 정적 내부 클래스
    - 구현 위치 - 외부 클래스 멤버 변수와 동일 
	- 사용할 수 있는 외부 클래스 변수 - 외부 전역변수
	- 생성 방법 - 외부 클래스와 무관하게 생성
  - 지역 내부 클래스 
    - 구현 위치 - 메서드 내부에 구현 
	- 사용할 수 있는 외부 클래스 변수 - 외부 인스턴스 변수, 외부 전역 변수
	- 생성 방법 - 메서드 호출할 때 생성 
  - 익명 내부 클래스 
    - 구현 위치 - 메서드 내부에 구현, 변수에 대입하여 직접 구현  
	- 사용할 수 있는 외부 클래스 변수 - 외부 인스턴스 변수, 외부 전역 변수
	- 생성 방법 - 메서드 호출할 때 생성되거나, 인터페이스 타입 변수에 대입할 때 new 예약어를 사용하여 생성 
	


## 람다식(lambda expression)
  - 자바에서 함수형 프로그래밍(functional programming)을 구현하는 방식 
  - 자바 8부터 지원 
  - 클래스를 생성하지 않고 함수의 호출만으로 기능을 수행 
  
  - 함수형 프로그래밍   
    - 순수 함수(pure function)를 구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않고 
	  매개 변수만을 사용하도록 만든 함수.
	- 함수를 기반으로 구현 
	- 입력 받은 자료를 기반으로 수행되고 외부에 영향을 미치지 않으므로 병렬처리 등에 가능
	- 안정적인 확장성 있는 프로그래밍 방식 
	
## 람다식 구현하기
  - 익명 함수 만들기 
  - 매개 변수와 매개 변수를 활용한 실행문 구현 - (매개변수) -> {실행문;}
  - 두 수를 입력 받아 더하는 add() 함수 
    - int add(int x, int y) {
			return x + y;
	  }
	  
	- (int x, int y) -> {return x + y;}
  - 함수 이름 반환 형을 없애고 -> 를 사용
  - {} 까지 실행문을 의미 
  
## 람다식 문법 
  - 매개변수(하나인 경우) 자료형과 괄호 생략하기 
    - str -> {System.out.println(str);}
	
  - 매개 변수가 두 개인 경우 괄호를 생략할 수 없음
    - x, y -> {System.out.println(x + y);} // 잘못된 형식 
	
  - 중괄호 안의 구현부가 한 문장인 경우 중괄호 생략 
    - str -> System.out.println(str);  
	
  - 중괄호 안의 구현부가 한 문장이라도 return문은 중괄호 생략할수 없음	
    - str -> return str.length(); // 잘못된 형식 
  
  - 중괄호 안의 구현부가 반환문 하나라면 return과 중괄호 모두 생략 
    - (x, y) -> x + y // 두 값을 더하여 반환함 
    - str -> str.length() // 문자열의 길이를 반환함.	


## 람다식 사용하기 예제 
  - 두 수중 더 큰 수를 반환하는 람다식 구현 활용 
  - 함수형 인터페이스 선언하기 
    - public interface MyNumber {
		int getMax(int num1, int num2);  // 추상 메서드 선언 
	  }
  - 람다식 구현과 호출 
    - public class TestMyNumber {
		public static void main(String[] args) {
			MyNumber max = (x, y) -> (x >=y) ? x : y;
			System.out.println(max.getMax(10,20));
		}
	  }

## 함수형 인터페이스 
  - 람다식을 선언하기 위한 인터페이스 
  - 익명 함수와 매개 변수만으로 구현되므로 단 하나의 메서드만을 가져야 함
    (두 개 이상의 메서드인 경우 어떤 메서드의 호출인지 모호해 짐)

  - @FunctionalInterface 애노테이션 
    - 함수형 인터페이스라는 의미, 여러 개의 메서드를 선언하면 에러남
	
## 익명 객체를 생성하는 람다식 
  - 자바는 객체 지향 언어로 객체를 생성해야 메서드가 호출 됨 
  - 람다식으로 메서드를 구현하고 호출하면 내부에서 익명 클래스가 생성됨 
    - StringConcat concat3 = new StringConcat() {
		@Override 
		public void makeString(String s1, String s2) {
			System.out.println(s1 + "," + s2);
		}
	  };
  - 람다식에서 외부 메서드의 지역변수는 상수로 처리 됨 
    (지역 내부 클래스와 동일한 원리)

## 함수를 변수처럼 사용하는 람다식 
  - 프로그램에서 변수의 사용은...
    - 특정 자료형으로 변수 선언 후 값 대입하여 사용하기 - int a = 10;
    - 매개변수로 전달하기 - int add(int x, int y);
    - 메서드의 반환 값으로 반환하기 - return num;
  - 인터페이스형 변수에 람다식 대입 
    - interface PrintString {
		void showString(String str);
	  }
	- s -> System.out.println(s)

    - PrintString lambdaStr = s -> System.out.println(s); // 인터페이스형 변수에 람다식 대입 
      lambdaStr.showString("hello lambda_1");	
	  

## 스트림(stream)
  - 자료의 대상과 관계없이 동일한 연산을 수행 
    - 배열, 컬렉션을 대상으로 동일한 연산을 수행 함. 
    - 일관성 있는 연산으로 차료의 처리를 쉽고 간단하게 함. 
  - 한 번 생성하고 사용한 스트림은 재사용 할 수 없음.
    - 자료에 대한 스트림을 생성하여 연산을 수행하면 스트림은 소모됨.
    - 다른 연산을 위해서는 새로운 스트림을 생성함.
  - 스트림 연산은 기존 자료를 변경하지 않음 
    - 자료에 대한 스트림을 생성하면 별도의 메모리 공간을 사용하므로 기존 자료를 변경하지 않음. 
  - 스트림 연산은 중간 연산과 최종 연산으로 구분 됨
    - 스트림에 대한 중간 연산은 여러 개 적용될 수 있지만 최종 연산은 마지막에 한 번만 적용됨.
    - 최종연산이 호출되어야 중간연산의 결과가 모두 적용됨. 이름 "지연 연산" 이라 함.


## 스트림 연산 - 중간 연산 
  - 중간 연산 - filter(), map()
    - 조건에 맞는 요소를 추출(filter()) 하거나 요소를 변환 함(map())

  - 문자열의 길이가 5 이상인 요소만 출력 하기 
    - sList.stream().filter(s -> s.length() >= 5).forEach(s -> System.out.println(s));

  - 고객 클래스에서 고객 이름만 가져오기 
    - customerList.stream().map((c -> c.getName()).forEach(s -> System.out.println(s));



14. 예외 처리 
  - 오류란 무엇인가요?
    - 컴파일 오류(compile error) - 프로그램 코드 작성 중 발생하는 문법적 오류 
	- 실행 오류(runtime error) - 시행 중인 프로그램이 의도 하지 않은 동작을 하거나(bug) 프로그램이 중지되는 오류 
	
	- 실행 오류시 비정상 종료는 서비스 운영에 치명적 
	- 오류가 발생할 수 있는 경우에 로그(log)를 남겨 추후 이를 분석할여 원인을 찾아야 함
	- 자바는 예외 처리를 통하여 프로그램의 비정상 종료를 막고 log를 남길 수 있음

## 오류와 예외 클래스 
  - 시스템 오류(error) - 가상 머신에서 발생, 프로그래머가 처리 할 수 없음
    - 동적 메모리 없는 경우, 스택 오버 플로우 등
  - 예외(Exception) : 프로그램에서 제어할 수 있는 오류 
    - 읽어 들이려는 파일이 존재하지 않는 경우, 네트웍 연결이 끊어진 경우 
	
  - Throwable <---------- Error
                  ㄴ------ Exception  

## 예외 클래스의 종류 
  - 모든 예외 클래스의 최상위 클래스는 Exception 
  - 다양한 예외 클래스가 제공 됨 
 
  - Exception <------ 입출력 예외 처리(IOException)        <---------  FileNotFoundException
                  |                                        ㄴ-----  SocketException
				  |-- 실행 오류 예외 처리(RuntimeException) <--------- ArithmeticException
                                                           ㄴ----- IndexOutofBoundsException


## try-with-resources문 
  - 리소스를 자동 해제 하도록 제공해 주는 구문
  - 자바 7 부터 제공 됨 
  - close()를 명시적으로 호출하지 않아도 try{} 블록에서 열린 리소스는 정상적인 경우, 예외 발생한 경우 모두 자동 해제 됨.  
  - 해당 리소스가 AutoCloseable을 구현 해야 함 
  - FileInputStream 의 경우 AutoCloseable을 구현하고 있음 

## 예외 처리 미루기 
  - throws 를 사용하여 예외처리 미루기 
  - 메서드 선언부에 throws를 추가 
  - 예외가 발생한 메서드에서 예외 처리를 하지 않고 이 메서드를 호출한 곳에서 예외 처리를 한다는 의미 
  - main()에서 throws를 사용하면 가상 머신에서 처리 됨  

## 사용자 정의 예외 
  - JDK에서 제공되는 예외 클래스 외에 사용자가 필요에 의해 예외 클래스를 정의하여 사용 
  - 기존 JDK 예외 클래스 중 가장 유사한 클래스에서 상속 
  - 기본적으로 Exception에서 상속해도 됨.
    - public class IDForamtException extends Exception {
		public IDFormatException(String message) {
			super(message);
		}
	  }  

15. 자바 입출력 

## 스트림이란?
  - 네트웍에서 자료의 흐름이 물과 같다는 의미에서 유래 
  - 다양한 입출력 장치에 독립적으로 일관성 있는 입출력을 제공하는 방식 
  - 입출력이 구현되는 곳 : 파일 디스크, 키보드, 마우스, 메모리 네트웍 등 
  
## 스트림의 구분 
  - 대상 기준 
    - 입력 스트림/출력 스트림 
  - 자료의 종류
    - 바이트 스트림/문자 스트림 
  - 기능
    - 기반 스트림/보조 스트림

## 입력 스트림과 출력 스트림 
  - 입력 스트림 : 대상으로 부터 자료를 읽어 들이는 스트림 
  - 출력 스트림 : 대상으로 자료를 출력하는 스트림 
  - 스트림의 종류 
    - 입력 스트림 : FileInputStream, FileReader, BufferedInputStream, BufferedReader 등 
    - 출력 스트림 : FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등 

## 바이트 단위 스트림과 문자단위 스트림 
  - 바이트 단위 스트림 : 동영상, 음악 파일 등을 읽고 쓸 때 사용 
  - 문자 단위 스트림 :
    - 바이트 단위로 자료를 처리하면 문자는 깨짐
    - 2 바이트 단위로 처리하도록 구현된 스트림
  - 스트림 종류
    - 바이트 스트림 : FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등 
    - 문자 스트림 : FileReader, FileWriter, BufferedReader, BufferedWriter 등 
	
## 기반 스트림과 보조 스트림
  - 기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림 
  - 보조 스트림 : 직접 읽고 쓰는 기능은 없이 추가적인 기능을 더해주는 스트림 
  - 보조 스트림은 직접 읽고 쓰는 기능은 없으므로 항상 기반 스트림이나 또 다른 보조 스트림을 생성자 매개변수로 포함 함.
    - 기반 스트림 + 보조 스트림 A + 보조 스트림 B
  - 스트림 종류 
    - 기반 스트림 : FileInputStream, FileOutputStream, FileReader, FileWriter 등 
    - 보조 스트림 : InputStreamReader, OutputStreamWriter, BufferedInputStream, BufferedOutputStream 등 
	
## 표준 입출력 
  - System 클래스의 표준 입출력 멤버 
        public class System {
			public static PrintStream out;
			public static InputStream in;
			public static PrintStream err;
  - System.out
		표준 출력(모니터) 스트림 
        System.out.println("에러 메시지");
  - System.in 
		표준 입력(키보드) 스트림 
		int d = System.in.read();  // 한 바이트 읽어내기 
  - System.err
		표준 에러 출력(모니터) 스트림 
		System.err.println("데이터"); 

## Scanner 클래스 
  - java.util 패키지에 있는 입력 클래스 
  - 문자뿐 아니라 정수, 실수 등 다른 자료형도 읽을 수 있음 
  - 여러 대상에서 자료를 읽을 수 있음(콘솔, 파일 등)
  - 생성자 
    - Scanner(File source) - 파일을 매개변수로 받아 Scanner를 생성함 
    - Scanner(InputStream source) - 바이트 스트림을 매개변수로 받ㅇ Scanner를 생성 함 
    - Scanner(String source) - String을 매개변수로 받아 Scanner를 생성 함. 
  - 메서드
    - boolean nextBoolean()
	- byte nextByte()
	- short nextShort()
	- int nextInt()
	- long nextLong()
	- float nextFloat()
	- double nextDouble()
	- String nextLine()

## Console 클래스 
  - System.in을 사용하지 않고 콘솔에서 표준 입력을 할 수 있음 
  - 이클립스와는 연동되지 않음
  - command창에서 입력 함 
  - 메서드 
    - String readLine()       - 문자열을 읽습니다.
	- char[] readPassword()   - 사용자에게 문자열을 보여 주지 않고 읽습니다.
	- Reader reader()         - Reader 클래스를 반환합니다.  
	- PrintWriter writer()    - PrintWriter 클래스를 반환합니다.

## 바이트 단위 스트림 - InputStream 
  - 바이트 단위 입력용 최상위 스트림 
  - 추상 메서드를 포함한 추상 클래스로 하위 클래스가 구현하여 사용 
  - 주요 하위 클래스 
    - FileInputStream - 파일에서 바이트 단위로 자료를 읽습니다. 
	- ByteArrayInputStream - Byte 배열 메모리에서 바이트 단위로 자료를 읽습니다. 
	- FilterInputStream - 기반 스트림에서 자료를 읽을 때 추가 기능을 제공하는 보조 스트림의 상위 클래스 임.
  - 메서드 
    - int read() 
    - int read(byte b[])
    - int read(byte b[], int off, int len)
    - void close()	

	
## 보조 스트림	
  - 실제 읽고 쓰는 스트림이 아닌 보조적인 기능을 추가하는 스트림 
  - 데코레이터 패턴 
  - FilterInputStream과 FilterOutputStream이 보조스트림의 상위 클래스 
  - 생성자의 매개변수로 또 다른 스트림을 가짐 
    - protected FilterInputStream(InputStream in)
    - public FileterOutputStream(OutputStream out) 
  - 기반 스트림[바이트 단위 파일 입력 스트림] + 보조 스트림[문자로 변환 기능 추가] + 보조 스트림[버퍼링 기능 추가]

  
	
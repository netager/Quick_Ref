1. 

2. 

## 6강. 노드의 모듈

### Node.js 모듈
- 프로그램을 작은 기능 단위로 쪼개고 파일 형태로 저장해 놓은 것
- 코드를 중복해서 작성하지 않아도 된다
- 수정이 필요할 경우 필요한 모듈만 수정하면 된다.

### CommonJS 모듈 시스템 Vs. ES 모듈 시스템
- CommonJS 모듈 시스템 : Node.js의 기본 모듈 시스템.(require, module.exports 사용)
- ES 모듈 시스템 : ECMAScript의 표준 모듈 시스템(import, export 사용)
- Node.js에서 ES 모듈 시스템 지원

### 노드 코어 모듈
- Node.js에 포함되어 있는 모듈
   - 파일 시스템(fs) - 파일이나 폴더에 접근할 수 있는 기능을 제공
   - HTTP(http) - HTTP 서버를 만들고 요청을 처리하는 기능을 제공
   - 경로(path) - 파일 경로와 관련된 작업을 하는 기능을 제공
   - 스트림(streams) - 데이터 스트림을 처리하는 기능을 제공
   - 암호화(crypto) - 암호화와 관련된 기능을 제공
   - 운영체제(os) - 운영체제와 상호 작용하는 기능을 제공
   - 유틸리티(util) - 다양한 유틸리티 함수를 제공
   - 이벤트)events) - 이벤트 기반 프로그래밍을 치원하는 기능을 제공

### 노드 코어 모듈 - 글로벌 모듈
- 글로벌 모듈 : require 없이 사용할 수 있는 모듈
- 글로벌 객체 : 글로벌 모듈에 있는 객체

예) 
- console 객체의 log 함수 사용
   - global.console.log(`${name}님, 안녕하세요?`);
- 글로벌은 코드 어디에서나 사용할 수 있어서 global 빼고 간단히 사용할 수 있음
   - console.log(`${name}님, 안녕하세요?`);

- __dirname : 현재 모듈이 있는 폴더 이름을 가져 옴
- __filename : 현재 모듈 파일의 이름을 가져 옴



## 7강. 노드의 path 모듈

### path 모듈 - path 모듈이 왜 필요할까
- 경로 구분자를 통일할 수 있다
   - 윈도우 - 역슬래시(\) 사용
   - 맥OS - 슬래시(/) 사용
- 경로를 나누거나 합칠 수 있다

### 절대 경로, 상대 경로
- 절대 경로
   - 파일이나 폴더의 위치를 루트 폴더부터 시작해서 파일까지 전부 나타내는 것

- 상대 경로
   - 기준이 되는 파일이 있을 경우 사용하는 경로
   - 같은 폴더에 있을 경우 './'로 표시하고 한단계 위 부모 폴더에 있을 경우 '../' 사용



## 8강. 노드의 fs(File System) 모듈

### 


## 9강. HTTP 모듈로 서버 만들기


## 10강. 라우팅

### 라우팅
- 라우팅이란 클라이언트에서 들어오는 요청에 따라 그에 맞는 함수를 실행하는 것
- (예) nodejs.org 사이트에서
   - nodejs.org/en/about로 요청하면 About Node.ja 화면으로 이동
   - nodejs.org/en/download라는 URL로 요청하면 Downloads 화면으로 이동
- 라우팅을 이용하면 사용자가 입력하는 URL에 따라 다른 내용을 보여 줄 수 있음
- GET이나 POST, PUT, DELETE 같은 요청 메서드에 따라 처리할 함수를 다르게 연결할 수도 있음



## 11강. 익스프레스

### 왜 익스프레스인가
- HTTP 모듈을 사용해서 서버를 만들 수 도 있지만
- 익스프레스에는 HTTP 모듈의 기능 외에도 다양한 기능이 포함되어 있음
   - 라우팅
      - HTTP 모듈을 사용할 때는 if문이나 switch 문으로 요청 메서드나 요청 URL에 따라 라우팅해야 했음. 하지만 익스프레스에서는 더욱 간편한 방법으로 라우팅할 수 있음.
   - 미들웨어
      -  익스프레스에는 '미들웨어'라는 개념이 있어서 요청과 응답 사이에서 여러 가지 기능을 실행할 수 있음. 이미 맣은 사용자들이 미들웨어를 만들어서 패키지로 제공하므로 자주 사용하는 미들웨어는 따로 만들 필요 없이 가져와서 사용할 수 있음
   - 템플릿 엔진
      - HTML 페이지는 기본적으로 정적이지만 서버와 함께 사용해서 동적인 HTML 페이지를 만들 수 있음. 애플리케이션에서 보이는 부분인 뷰를 담당.  
   - 정적인 파일 지원
      - 익스프레스에서 동적인 파일만 생성하는 것은 아님. CSS 파일이나 JS 파일, 이미지처럼 정적인 파일을 쉽게 서비스할 수 있는 기능도 제공.
- 많은 사용자들이 선택한 프레임워크


### 설치
- npm init (doint-node-main/myContacts 디렉토리에서 실행)
- npm i express
- npm i nodemon --save-dev -g


## 12강. 익스프레스 라우팅

### 라우트 파라미터 사용하기
- 특정 조건을 지정할 때 라우팅 코드에서 요청 URL 뒤에 :를 붙인 후 그 뒤에 변수 작성
   - /요청 URL/:id
- 요청 할 때는 요청 URL 뒤에 조건 값 지정
   예) 연락처 정보 중에서 아이디가 '1'인 것을 가져오려면 /contacts/1

- 여기에서 작성할 라우트 코드는?
   - GET - /contacts/:id - id에 맞는 연락처 가져오기
   - PUT - /contacts/:id - id에 맞는 연락처 수정하기
   - DELETE - /contacts/:id - id에 맞는 연락처 삭제하기

### 익스프레스 요청 객체의 속성
- req.body - 서버로 POST 요청할 때 넘겨준 정보를 담고 있음
- req.cookies - 클라이언트에 저장된 쿠키 정보를 서버로 함께 넘겼을 경우 쿠키 정보를 담고 있음
- req.headers - 서버로 요청을 보낼 때 같이 보낸 헤더 정보를 담고 있음
- req.params - URL 뒤에 라우트 파라미터가 포함되어 있을 경우 파라미터 정보를 담고 있음
- req.query - 요청 URL에 포함된 질의 매개변수(쿼리, query)를 담고 있음


### 익스프레스 응답 객체의 속성
- res.download - 파일을 내려 받습니다.
- res.end - 응답 프로세스를 종료합니다.
- res.json - JSON 응답을 전송합니다.
- res.jsonp - JSONP 지원을 통해 JSON 응답을 전송합니다.
- res.redirect - 요청 경로를 재지정해서 강제 이동합니다.
- res.render - 뷰 템플릿을 화면에 렌더링합니다.
- res.send - 어떤 유형이든 res.send() 괄호 안의 내용을 전송합니다.
- res.sendFile - 지정한 경로의 파일을 읽어서 내용을 전송합니다.
- res.sendStatus - 상태 메시지와 함께 HTTP 상태 코드를 전송합니다.
- res.status - 응답의 상태 코드를 설정합니다.


## 13강. 익스프레스 라우터 미들웨어

### 미들웨어란?
- 요청과 응답 중간에 있으면서 요청을 처리하거나 원하는 형태로 응답을 수정하는 기능을 가진 함수
- 예)
   - 1) 요청 안에 포함된 아이디와 비밀번호의 값을 애플리케이션에서 읽을 수 있는 형태로 변환(파싱이라고 함)
   - 2) 아이디와 비밀번호의 값을 사용해서 사용자 인증
   - 3) 처리 결과를 다음 단계(예를 들어, 화면 렌더링)로 넘겨 줌

### 미들웨어의 역할(종류)
- 요청 전처리 - 요청이 서버에 도착하기 전에 실행하는 작업을 담당. 예를 들어 사용자 인증이나 폼 내용 검증 등의 작업을 처리
- 라우팅 처리(라우터 미들웨어) - 지금까지 특정 URL로 들어온 요청을 미리 만들어 둔 함수(라우트 핸들러)로 연결했음. 이런 라우트 코드를 좀 더 읽기 쉽고 관리하기 쉽도록 모듈화하는 라우터 미들웨어도 있음
- 응답 처리 - 서버에서 클라이언트로 응답을 보낼 때 자료를 적절한 형태로 변환하거나 오류를 처리하는 작업을 함

### 애플리케이션 레벨 미들웨어
- 애플리케이션 단계에서 사용하는 미들웨어
   - app.get("/contacts", (req, res) => {...});
   - app.get("/contacts:id", (req, res) => {...});


### 라우터 미들웨어
- 라우터 객체를 통해 라우트 코드 정리
   - 1) router 객체 만들기
          - const router = express.Router();
   - 2) router 객체를 사용해 라우트 코드 작성
          - router.route("/contacts")
               .get((req, res) => {...})
               .post((req, res) => {...});
          - router.route("/contacts:id")
               .get((req, res) => {...})
               .put((req, res) => {...})
               .delete((req, res) => {...});
   - 3) app.js에서 router 객체를 미들웨어로 등록
          - app.use(router);

## 14강. 익스프레스 바디파서 미들웨어

### 바디파서 미들웨어
- 서버로 요청을 보낼 때 요청 본문에 담긴 것을 파싱하는 미들웨어
   - 파싱 : 요청할 때 전송한 자료를 프로그램에서 사용할 수 있는 형식으로 변환하는 것

- 바디파서는 요청 본문에 어떤 유형의 자료를 포함하는 가에 따라 사용하는 함수가 달라짐
   - .json() - JSON 형식의 본문을 파싱합니다.
   - .urlencodeded() - URL로 인코딩된 본문을 파싱합니다.
   - .raw() - 가공되지 않은 바이너리 자료를 파싱합니다.
   - .text() - 텍스트 형식의 본문을 파싱합니다.

- JSON 형식이나 urlencoded 형식을 처리할 경우 익스프레스 내장 함수를 사용
   - app.use(express.json());
   - app.use(express.urlencoded({ extended: true }));
    - true : 중복된 자료를 처리 - 일반적으로 true 사용
    - false : 단순한 자료 처리


## 15강. 몽고DB 설정하기

###  웹과 데이터베이스
- 웹 사이트(애플리케이션)과 관련된 여러 정보를 정장하고 있는 공간
- 사이트나 애플리케이션이 쉽게 접근할 수 있도록 자료를 효율적으로 구성하는 것이 중요

### 데이터베이스의 종류
- 관계형 데이터베이스 - Oracle
   - 저장할 자료의 구조를 행과 열로 구분해서 표 형태로 관리
   - 표와 표를 연결해서 사용하기도 함
   - SQL 언어를 사용하므로 SQL 데이터베이스라고도 함

- NoSQL 데이터베이스 - Mongo
   - SQL 언어를 사용하지 않기 때문에 NoSQL 데이터베이스라고 함
   - 문서 형태로 자료 저장
   - 새로운 필드를 추가하기도 쉽고 기존 필드를 수정할 수도 있음
   - 따로 데이터베이스 언어를 공부하지 않아도 됨
   - 자료를 여러 컴퓨터에 나누어 저장할 수도 있음

### 몽고 DB란?
- NoSQL 데이터베이스의 한 종류
- JSON 형식으로 자료 저장
- 서버에 데이터베이스를 만들 수도 있고 클라우드에서 데이터베이스를 사용할 수도 있음
   - 몽고DB 아틀라스


## 16강. 몽고DB 사용하기
- 관련 모듈 설치
   - npm i mongoose dotenv


## 17강. 스키마와 모델

### 스키마 - 도큐먼트 - 컬렉션
- 스키마(schema) : 애플리케이션에서 사용할 자료의 형태를 정하는 것
- 스키마 파일은 애플리케이션 코드와 별도의 파일을 작성한다 -> 코드의 재사용성이 높아진다.


### 스키마 정의하기


### 스키마를 모델로 변환



## 18강. 컨트롤러 만들기

### API와 애플리케이션
- 애플리케이션
   - 특정 기능을 제공하는 프로그램. 그 자체로 완전한 소프트웨어
   - 사용자 인터페이스도 있고, 사용자와 상호 작용하는 기능을 모두 포함
   - (예) SNS 애플리케이션

- API
   - 애플리케이션 간에 자료를 주고받으면서 특정 기능 실행
   - API를 사용하면 다른 시스템끼리 자료를 주고 받을 수도 있고 새로운 애플리케이션을 만들 수도 있음
   - (예) SNS 애플리케이션에서 사용하는 로그인 API, 게시물 작성 API 등
   - (예) 소셜 로그인 API 처럼 API를 공개할 경우 다른 애플리케이션에서 사용 가능   

### RESTful API
- REST
   - HTTP 프로토콜을 활용해서 자료를 주고 받기 위해 약속된 구조
   - representational state traansfer의 줄임말. 여기에서 representational state는 데이터의 현재 상태를 볼 수 있게 나타낸 것
   - (예) 온라인 쇼핑몰에서 장바구니에 어떤 상품을 담았는지 보여 주는 것이 상태를 나타내는 것
   - 데이터 상태를 주고 받을 때 사용하는 것이 REST

- RESTful API
   - REST를 지켜서 개발한 API
   - REST API라고도 함

- URI로 자원 요청
   - API에서 주고 받는 자원의 위치는 URI를 사용해 표현
   - (예) http://localhost:3000/contacts/10
      -  http - 프로토콜
      - localhost - 도메인
      - 3000 - 포트
      - contacts - 자원
      - 10 - sid 인자

### RESTful API에서 URI를 지정할 때 지키면 좋은 약속
- 자원 이름은 명사형으로 알파벳 소문자 사용
   - (예) http://product.kyobobook.co.kr/detail/S000001818002
- 자원 이름으로 단어를 2개 이상 사용한다면 붙임표(-)로 연결
   - (예) https://github.com/microsoft/vscode-docs
- 단어가 2개 이상일때 카멜 표기버을 사용하기도 함
   - (예) https://comic.naver.com/bestChallenge
- 자원 간에 계층이 있다면 슬래시(/)로 구분하되 URI 끝에는 슬래시를 붙이지 않음
   - (예) https://v.daum.net/channel/90/home
- 자원 처리 방법은 URI에 포함시키지 않음
   - (예) localhost:3000/contacts (O)
        localhost:2000/get-contacts(X)
   
### RESTful API - HTTP 요청 방식과 역할
- POST     - Create  - 자원을 새로 만듭니다.
- GET      - Read      - 자원을 가져옵니다.
- PUT      - Update   - 자원을 수정합니다.
- DELETE - Delete   - 자원을 삭제합니다.

- C - Create - POST
- R - Read   - GET
- U - Update - PUT
- D - Delete - DELETE


### MVC 패턴
- 소프으웨어의 코드는 수천 수만 줄의 코드로 이루어짐 -> 효율적으로 구성하려면?
- 코드의 기능이나 역할에 따라 여러 파일로 나눈 뒤 연결해서 사용(디자인 패턴)
- MVC 패턴은 model, view, controller의 앞자를 따서 이름을 붙인 패턴

- 모델
   - 애플리케이션에서 처리할 대상입니다.
   - 데이터베이스를 통해 자료를 저장하거나 검색, 수정하는 함수들이 모델에 해당합니다.
   - 사용자에게 어떻게 보일지는 신경 쓰지 않고 처리할 대상에 집중합니다.
- 뷰
   - 컨트롤러나 모델의 처리 결과를 시각적으로 보여줍니다.
   - 흔히 사이트나 애플리케이션에 표시되는 화면을 만듭니다.
   - 서버에서 가져온 동적 자료를 표시하므로 템플릿 형태로 처리합니다.
- 컨트롤러
   - 모델과 뷰 중간에 위치하면서 요청에 따라 모델이나 뷰를 수정하는 역할을 합니다.
   - Node.js에서 작성하는 라우트 코드가 컨틀롤러에 해당합니다.
   - 코드를 가장 많이 작성하는 부분입니다. 그래서 이 책에서는 라우트 코드에서 함수 부분만 분리해서 작성한다.

### MVC 패턴 - 라우터 따로 사용하기
- 뷰와 컨트롤러 중간에 라우터 사용
- 나중에 라우트 코드는 건드리지 않고 함수 부분만 수정 가능

### 컨트롤러 작성하기

- npm i express-async-handler

### CRUD 코드 작성하기

### 데이터베이스 모델에서 사용하는 함수
- create 함수 - 데이터베이스에 새로운 도큐먼트를 만듦
   - Contact.create({name: 'Kim', email: 'kim@abc.def', phone: '12345'})

- find 함수 - 조건에 맞는 도큐먼트를 찾음. 조건을 지정하지 않으면 모든 도큐먼트를 찾음
   - Contact.find()
   - Contact.find({ name: 'Kim' })

- findOne 함수 - 조건에 맞는 도큐먼트가 여러개일 경우 첫 번째 도큐먼트를 찾음
   - Contact.findOne( {name: 'Kim' })

- updateOne, updateMany 함수 - 지정한 조건에 해당하는 도큐먼트를 찾아 내용을 업데이트 함
   - updateOne 함수 - 조건에 맞는 첫 번째 도큐먼트만 업데이트
   - updateMany 함수 - 조건에 맞는 모든 도큐먼트 업데이트
      - Contact.updateOne( {name: 'Kim'}, {phone: '67890'} )

- deleteOne, deleteMany 함수 - 지정한 조건에 해당하는 도큐먼트를 찾아 내용을 삭제함
   - deleteOne 함수 - 조건에 맞는 첫 번째 도큐먼트만 삭제
   - deleteMany 함수 - 조건에 맞는 모든 도큐먼트 삭제
   - Contact.deleteMany( { name: 'Kim' })
 
- findById 함수 - 아이디 값을 기준으로 도큐먼트를 찾음
   - Contact.findById('12345')

- findByIdAndUpdate, findByIdAndDelete 함수 - 지정한 id에 해당하는 도큐먼트를 찾아 업데이트하거나 삭제함
   - Contact.findByIdAndUpdate(
	id,
	{ name, email, phone },
    );
   - Contact.findByIdAndDelete(req.params.id);


## 20강. EJS 엔진 사용법

### 템플릿 엔진이란
- HTML 파일처럼 정적인 파일을 연결하는 것은 어렵지 않다
- 사용자 동작(요청)에 따라 내용이 달라지는 동적인 콘텐츠를 가져와서 보여주려면 템플릿 엔진 필요
   - 템플릿을 만들어 놓고 데이터베이스에서 내용을 가져와 채워 넣으면 됨

* 템플릿 파일 : 데이터베이스에서 가져온 데이터 중 어떤 값을 어느 위치에 넣을지 미리 만들어 놓은 틀
* 템플릿 엔진 : 템플릿 파일을 만들고 데이터베이스에서 가져온 동적인 데이터를 템플릿 파일에 연결하는 역할

### 뷰 엔진 설정하기 - EJS
- 노드에서 앞으로 어떤 템플릿을 엔진을 사용할 것인지 알려주는 과정 필요
   - app.set(키, 값)

- view engine
   - 뷰에서 사용할 템플릿 엔진을 설정
   - (예) EJS 엔진을 사용한다면 - app.set("view engine", "ejs")

- views
   - 템플릿 엔진이 템플릿을 어디에서 찾을지 경로 설정. EJS 엔진에서는 기본적으로 views 폴더에 템플릿 파일 저장
     - app.set("views", "./views")

### EJS 엔진 사용하기
- 패키지 설치 : npm i ejs

### EJS 엔진의 기본 사용법
- 컨트롤러에서 템플릿 파일로 값 넘기기 - res.render 함수
   - res.render(ejs 파일, {변수: 전송 자료})
   - (예) getAll.ejs 파일에 User List라는 텍스트를 넘겨줄 때 heading 변수 사용
      - res.render("getAll", { heading: "User List" });

- 템플릿 파일에서 동적인 콘텐츠 처리하기 - EJS 태그
   - <%= 변수 %>
      <% 자바스크립트 코드 %>
      <%- HTML 코드 %>
   - (예)
      - heading 변수의 값 표시
          - <%= heading %>
    - 자바 스크립트 코드 작성
          - <% if (age > 10) { %>
        	<p>나이 : <%= age %> </p>
             <% } else { %>
    		<p>나이가 너무 어립니다.</p>
             <% } %>
      - HTML 코드 삽입
         - <%- include('include/header') %> 

### 템플릿 파일로 값 넘겨주기

### 정적인 파일 연결하기
- 웹에서 사용하는 CSS 파일이나 JS 파일, 이미지 등은 정적인 파일 -> 별도의 폴더에 모아놓고 사용함
- 주로 public 폴더에 모아 두고 express.static 함수를 사용해 연결해 줌
   ① 작업 폴더에 public 폴더를 만들고
   ② public 안에 css 폴더를 만든 후 assets\css 폴더에 있는 style.css 파일 복사해 붙여넣기
   ③ app.js 에서 정적인 파일이 어디 있는지 코드 추가
       - app.use(express.static("./public"));


## 21강. 전체 연락처 표시하기

### 필요한 ejs 파일
- index.ejs
- add.ejs
- update.ejs


## 22강. 연락처 추가하기

### 처리할 내용
- 전체 연락처 화면에서 [연락처 추가] 버튼 클릭 -> 추가 화면 보여주기
- 주가 화염에서 정보 입력하고 [저장하기] 버튼 클릭 -> 데이터베이스에 연락처 추가

- npm -i method-override


## 25강. 관리자 등록하기


### 비밀번호 암호화하기 - bcrypt 모듈
- 해시함수란
   - 입력값을 받아서 또 다른 값을 반환하는 함수. 반환하는 값을 해시(hash)라고 함
   - 해시 함수는 일방향 함수 - 해시만 보고 원래 값을 복원하는게 거의 불가능
   - 입력값이 같으면 항상 같은 해시를 반환하지만, 조금만 변경해서 완전히 다른 값이 됨
      - (예) 123과 1234는 한 글자만 다르지만 해시는 완전히 다른 값 - 해시만 보고 값을 추측할 수 없음

### 비밀번호 암호화 하기 - bcrypt 모듈
- bcrypt 모듈을 사용해 해시하기
   - 기본형 : bcrypt.hash(data, saltRounds, callback)
     - data : hash하려는 값
        - saltRounds : 해시를 반복할 횟수
        - 입력값을 해시한 후에 실행할 함수
   - (예) 
	const password = "1234";
        bcrypt.hash(password, 10, (err, hash) => {
		try {
			//해시된 비밀번호(hash)를 데이터베이스에 저장하거나 다른처리
 		} catch (error) {
			// 오류 처리
		}
	});

- 비밀번호 확인하기
   - 비밀번호를 비교할 때는 사용자가 입력한 비밀번호를 해시한 후 데이터베이스에 있는 해시값과 같은지 확인
   - 기본형 : bcrypt.compare(data, encrypted, callback)
    - data : 비교할 입력값
      - encrypted : 비교할 대상
      - callback : 값 2개를 비교한 후에 실행할 함수

- 패키지 설치
   - npm i bcrypt


## 26강. 사용자 인증하기

### JWT(JSON Web Token)
- JWT 공식 웹 사이트(https://jwt.io/)에 접속하기
- JWT 토큰의 기본 형태
   - 헤더.페이로드.서명
      - 헤더
         - 토큰의 알고리즘과 유형이 담겨 있음. 각각의 필드를 헤더 파라미터라고 함
            - 'alg' 파라미터 : 토큰에 사용한 서명 알고리즘
            - 'typ' 파라미터 : 토큰의 유형
      - 페이로드 - 암호화된 정보
         - 사용자 인증 정보가 담여 있음. 페이로드에 있는 가각의 필드를 클레임 이라고 함
            - 'sub' 클레임 : 토큰 제목
            - 'name' 클레임 : 사용자 이름
            - 'iat' 클레임 : 토큰 발급 시간
      - 서명
        - 헤더와 페이로드 뒤에 붙이는 비밀 키입니다. 이 비밀키는 외부로 공개하면 안 되므로 .env 파일처럼 서버의 안전한 곳에 저장해 두고 사용합니다.
  

### 토큰 방식이란?
- 세션 : 서버에 저장되어 있으면서 클라이언트에 있는 세션 ID와 비교해서 사용자
- 토큰 : 인증할 대 필요한 모든 정보가 포함되어 있으면서 특정 서버에 저장하지 않음. 서버간 공유도 가능


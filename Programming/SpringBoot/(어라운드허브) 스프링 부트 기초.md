# 1강 스프링 부트 프로젝트 생성
<br>

# 2강 SpringBoot 기초 - 디자인 패턴

## GoF 디자인 패턴

### 목적에 따른 분류
- 생성 패턴, 구조 패턴, 행동 패턴 총 3가지로 구분됨
- 각 패턴이 어떤 작업을 위해 생성되는 것인지에 따른 구분

|생성패턴|구조패턴|행동패턴|
|---|---|---|
|Abstract Factory|Adapter|Chain of Responsibility|
|**Builder**| Bridge| Command|
|Factory Method|Composite|Command|
|Prototype|Decorator|Interpreter|
|**Singleton**|Facade|iterator|
||Flyweight|Mediator|
||Proxy|Memonto|
|||Observer|
|||State|
|||Strategy|
|||Template Method|
|||Visitor|
<br>

### 생성 패턴
- 생성 패턴은 객체의 생성과 관련된 패턴
- 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 최소화할 수 있도록 유연성 제공

|생성패턴|의도|
|---|---|
|추상 팩토리(Abstract Factory)|구체적인 클래스를 지정하지 않고 인터페이스를 통해 연관되는 객체들을 묶어줌|
|빌더(Builder)|객체의 생성과 표현을 분리하여 객체를 생성|
|팩토리 메소드(Factory Method)|객체 생성을 서브클래스로 분리하여 위임(캡슐화)|
|프로토타입(Prototype)|원본 객체를 복사하여 객체를 생성(클론)|
|**싱글톤(Singleton)**|한 클래스마다 인스턴스를 하나만 생성하여 어디서든 참조|
<br>

### 구조 패턴
- 구조 패턴은 프로그램 내 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 사용되는 패턴
- 클래스나 객체를 조합하여 더 큰 구조를 만들 수 있게 해줌

|구조패턴|의도|
|---|---|
|**어뎁터(Adapter)**|클래스의 인터페이스를 어떤 클래스에서든 이용할 수 있도록 변환|
|**브리지(Bridge)**|구현부에서 추상층을 분리하여 각자 독립적으로 변형하고 확장할 수 있도록 함|
|컴포지트(Composite)|객체들의 관례를 트리 구조로 구성하여 표현하는 방식으로 복합 객체와 단일 객체를 구분없이 다룸|
|**데코레이터(Decorator)**|주어진 상황에 따라 객체에 다른 객체를 덧붙임|
|**파사드(Facade)**|서브 시스템에 있는 인터페이스 집합에 대해 통합된 인터페이스 제공|
|플라이웨이트(Flyweight)|크기가 작은 여러개의 객체를 매번 생서하지 않고 최대한 공유하여 사용하도록 메모리 절약|
|프록시(Proxy)|실제 기능을 수행하는 객체 대신 가사으이 객체를 사용해 로직의 흐름을 제어|

### 행동(행위) 패턴
- 행동 패턴은 반복적으로 사용되는 객체들의 커뮤니케이션을 패턴화
- 객체 사이에 알고리즘 또는 책임을 분배하는 방법에 대해 정의됨
- 결합도를 최소화 하는 것이 주 목정

|행동 패턴|의도|
|---|---|
|책임연쇄(Chain of Responsibility)|요청을 받는 객체를연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달|
|커맨드(Command)|요청을 객체의 형태로 캡슐화하여 재사용하거나 취소|
|인터프리터(Interpreter)|특정 언어의 문법 표현을 정의|
|반복자(Iterator)|컬렉션 구현 방법을 노출하지 않으면서 모든 항목에 접근할 수 있는 방법을 제공|
|중재자(Mediator)|한 집합에 속해있는 객체들의 상호작요을 캡슐화하여 새로운 개체로 정의|
|메멘토(Memento)|객체가 특정 상태로 다시 되돌아 올 수 있도록 내부 상태를 실체화|
|옵저버(Observer)|객체 상태가 변할 때 관련 객체들이 그 변화를 전달받아 자동으로 갱신|
|상태(State)|객체의 상태에 따라 동일한 동작을 다르게 처리|
|전략(Strategy)|동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호 교환이 가능하게 함|
|템플릿 메소드|상위 클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브 클래스로 위임|
|방문자(Visitor)|객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성|
<br>

# 3강 Spring Boot 기초 - REST API

## API 란?
- Application Programming Interface의 줄임말
- 응용 프로그램에서 사용할 수 있도록 다른 응용 프로그램을 제어할 수 있게 만든 인터페이스를 뜻함
- API를 사용하면 내부 구현 로직을 알지 못해도 정의되어 있는 기능을 쉽게 사용할 수 있음

- 여기서 인터페이스(Interface)란 어떤 장치간 정보를 교환하기 위한 수단이나 방법을 의미함
- 대표적인 인터페이스 예로는 마우스, 키보드, 터치패드 등이 있음

## REST 란?
- REST는 Representational State Transfer의 줄임말
- 자원의 이름으로 구분하여 해당 자원의 상태를 교환하는 것을 의미
- REST는 서버와 클라이언트의 통신 방식중의 하나임
- HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고 HTTP Method를 통해 자원을 교환하는 것
- cf) HTTP Method : Create, Read, Update, Delete

## REST 특징
### Server-Client 구조
- 자원이 있는 쪽이 Server, 요청하는 쪽이 Client
- 클라이언트와 서버가 독립적으로 분리되어 있어야 함

### Stateless
- 요청 간에 클라이언트 정보가 서버에 저장되지 않음
- 서버는 각각의 요청을 완전히 별개의 것으로 인식하고 처리

### Cacheable
- HTTP 프로토콜을 그대로 사용하기 때문에 HTTP의 특징인 캐싱 기능을 적용
- 대량의 요청을 효율적으로 처리하기 위해 캐시를 사용

### 계층화(Layered System)
- 클라이언트는 서버의 구성과 상관없이 REST API 서버로 요청
- 서버는 다중 계층으로 구성될 수 있음(로드밸런싱, 보안 요소, 캐시 등)

### Code on Demand(Optional)
- 요청을 받으면 서버에서 클라이언트로 코드 또는 스크립트(로직)을 전달하여 클라이언트 기능 확장

### 인터페이스 일관성(Uniform Interface)
- 정보가 표준 형식으로 전송되기 위해 구성 요소간 통합 인터페이스를 제공
- HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능하게끔 설계

## REST의 장점
- HTTP 표준 프로토콜을 사용하는 모든 플랫폼에서 호환 가능
- 서버와 클라이언트의 역할을 명확하게 분리
- 여러 서비스 설계에서 생길 수 있는 문제를 최소화

## REST API란?
- REST 아키텍처의 조건을 준수하는 어플리케이션 프로그래밍 인터페이스를 뜻함
- 최근 많은 API가 REST API로 제공되고 있음
- 일반적으로 REST 아키텍처를 구현하는 웹 서비스를 RESTful 하다고 표현한다.

## REST API 특징
- REST 기반으로 시스템을 분산하여 확장성과 재사용성을 높임
- HTTP 표준을 따르고 있어 여러 프로그래밍 언어로 구현할 수 있음

## REST API 설계 규칙
### 웹 기반의 REST API를 설계할 경우에는 URI를 통해 자원을 표현해야 함
- https://thinkground.studio/member/589
- Resource:member
- Resource id:589

### 자원에 대한 조작은 HTTP Method(CRUD)를 통해 표현해야 함
- URI에 행위가 들어가면 안됨
- HEADER를 통해 CRUD를 표현하여 동작을 요청해야 함

### 메시지를 통한 리소스 조작
- HEADER를 통해 content-type을 지정하여 데이터를 전달
- 대표적인 형식으로는 HTML, XML, **JSON**, TEXT가 있음

### URI에는 소문자를 사용
### Resource의 이름이나 URI가 길어질 경우 하이픈(-)틀 통해 가독성을 높일 수 있음
### 언더바(_)는 사용하지 않음
하이퍼링크와 같이 사용시 안보이는 것을 피하고자 함
### 파일 확장자를 표현하지 않음

# Spring Boot 기초 - pom.xml 설정하기

## Maven

## pom.xml
- Maven 프로젝트를 생성하면 루트 디렉토리에 생성되는 파일
- Project Object Model 정보를 담고 있음
- 주요 설정 정보
    - 프로젝트 정보 : 프로젝트의 이름, 개발자 목록, 라이센스 등
    - 빌드 설정 정보 : 소스, 리소스, 라이프 사이클 등 실행할 플러그인 등
    - POM 연관 정보 : 의존 프로젝트(모듈), 상위 프로젝트, 하위 모듈 등

## 프로젝트 기본 정보
pom 파일에서 프로젝트 정보와 관련된 태그는 아래와 같음
- <name> : 프로젝트 명
- <url> : 프로젝트 사이트 URL
- <description> : 프로젝트에 대한 간단한 설명
- <oraganization> : 프로젝트를 관리하는 단체 설명

## 프로젝트 연관 정보
pom 파일에서 프로젝트 정보와 관련된 태그는 아래와 같음
- <groupId> : 프로젝트의 그룹 ID 설정
- <artifactId> : 프로젝트 아티팩트 ID 설정
- <version> : 프로젝트의 버전
- <packaging> : 패키징 타입 설정
    - jar : 자바 프로젝트 압축 파일
    - war : 웹 어플리케이션을 위한 패키징 방식

<br>

## 프로젝트 의존 설정
프로젝트에서 사용하는 라이브러리에 대한 의존성 설정과 관련된 태그는 아래와 같음
- <dependencies> : 라이브러리 의존성 정보를 가지고 있는 dependency 태그를 묶은 태그
- <dependency> : 각 라이브러리의 정보를 담는 태그
- <groupId> : 의존성 라이브러리의 groupID
- <artifactId> : 의존성 라이브러리의 아티팩트 ID
- <version> : 의존성 라이브러이의 버전
- <scope> : 해당 라이브러리의 이용 범위를 지정
- <optional> : 다른 프로젝트에서 이 프로젝트를 의존성 설정을 할 경우 사용할지 결정

## scope 태그
### compile(default)
- 아무것도 지정되지 않았을 경우 설정되는 값
- 이 값으로 설정하는 경우 모든 클래스 경로에서 사용할 수 있음
- 컴파일 및 배포 상황에서 같이 제공됨

### provided
- compile과 유사 하지만 JDK 혹은 Container가 런타임 시에만 제공
- 컴파일 혹은 테스트 경로에서만 사용하며, 배포 시에는 빠짐

### runtime
- 컴파일 시에는 사용하지 않고, 실행 상황에서만 사용됨
- 런타임과 테스트 경로에서는 있지만, 컴파일 클래스 경로에는 존재하지 않음

### test
- 테스트 상황에서만 사용되는 라이브러리를 의미
- 실 가동 상황에서는 필요 없는 라이브러리를 사용할 경우에 설정
- 종속된 다른 프로젝트에는 영향을 미치지 않음

### system
- provide와 유사하지만 저장소에서 관리되지 않고 직접 관리하는 JAR를 추가
- systemPath를 추가해서 작성해야 함

## 현재 시점에서 설정되어 있는 라이브러리 설명
### Spring Boot Starter Parent
- 프로젝트에서 사용하는 다양한 라이브러리 간의 버전 충돌 문제가 발생할 수 있는 것을 방지
- 의존성 조합간 충돌 문제가 없는 검증된 버전 정보 조합을 제공

### Spring Boot Starter Web
- Spring MVC를 사용한 REST 서비스를 개발하는데 사용

### SPring Boot Starter Test
- JUnit, Hamcrest, Mockito를 포함한 스프링 어플리케이션의 테스트 기능을 제공

# Spring Boot 기초 - MVC 패턴
## MVC(Model View Controller)
디자인 패턴 중 하나인 MVC 패턴은 Model, View, Controller의 줄임말로 어플리케이션을 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴을 의미

사용자 인터페이스로부터 비즈니스 로직을 분리하여 서로 영향없이 쉽게 고칠 수 있는 설계가 가능

## 컨트롤러(Controller)
- 모델(Model)과 뷰(View) 사이에서 브릿지 역할을 수행
- 앱의 사용자로부터 입력에 대한 응답으로 모델 및 뷰를 업데이트 하는 로직을 포함
- 사용자의 요청은 모두 컨트롤러를 통해 진행되어야 함
- 컨트롤러로 들어온 요청은 어떻게 처리할지 결정하여 모델로 요청을 전달함
- ex) 쇼핑몰에서 상품을 검색하면 그 키워드를 컨트롤러가 받아 모델과 뷰에 적절하게 입력을 처리하여 전달함

## 모델(Model)
- 데이터를 처리하는 영역
- 데이터베이스와 연동을 위한 DAO(Data Access Object)와 데이터의 구조를 표현하는 DO(Data Object)로 구성됨
- 예) 검색을 위한 키워드가 넘어오면 데이터베이스에서 관련된 상품의 데이터를 받아 뷰에 전달

## 뷰(View)
- 데이터를 보여주는 화면 자체의 영역을 뜻함
- 사용자 인터페이스(UI) 요소들이 여기에 포함되며, 데이터를 각 요소에 배치함
- 뷰에서는 별도의 데이터를 보관하지 않음
- 예) 검색 결과를 보여주기 위해 모델에서 결과 상품 리스트 데이터를 받음

## MVC 패턴의 특징
- 어플리케이션의 역할을 세 구간으로 나누어 설계함으로써 서로 간의 의존성이 낮아짐
- 각 영역이 독립적으로 구성되어 개발자 간 분업 및 협업이 원할해짐
- 한 영역을 업데이트 하더라도 다른 곳에 영향을 주지 않음

# Hello World 응답하기

## @RestController
- Spring Framework 4 부터 사용가능한 어노테이션
- @Controller에 @ResponseBody가 결합된 어노테이션
- 컨트롤러 클래스 하위 메소드에 @ResponseBody 어노테이션을 붙이지 않아도 문자열과 JSON 등을 전송할 수 있음
- View를 거치지 않고 HTTP ResponseBody에 직접 Reburn값을 담아 보내게 됨


## @RequestMapping
- MVC의 핸들러 매핑(Handler Mapping)을 위해서 DefaultAnnotationHandlerMapping을 사용
- DefaultAnnotationHandlerMapping 매핑정보로 @Requestmapping 어노테이션을 활용
- 클래스와 메소드의 RequestMapping을 통해 URL을 매핑하여 경로를 설정하여 해당 메소드에서 처리
    - value : url 설정
    - method : GET, POST, DELETE, PUT, PATCH 등
- 스프링 4.3버전 부터 메소드를 지정하는 방식보다 간단하게 사용할 수 있는 어노테이션을 사용할 수 있음
    - @GetMapping
    - @PostMapping
    - @DeleteMapping
    - @PutMapping
    - @PatchMapping


# GET API

## @RequestMapping
- value와 method로 정의하여 API 개발하는 방식
- 이제는 고전적인 방법으로 사용하지 않음

```java
@RequestMapping(value="/hello", method=RequestMethod.GET)
public String getHello() {
    return "Hello World";
}
```

## @GetMapping(without Param)
- 별도의 파라미터 없이 GET API를 호출하는 경우 사용되는 방법

```java
@GetMapping(value="/name")
public String getName() {
    return "Flature";
}
```

## @PathVariable
- GET 형식의 요청에서 파라미터를 전달하기 위해 URL에 값을 담아 요청하는 방법
- 아래 방식은 @GetMapping에서 사용된 {변수}의 이름과 메소드의 매개변수와 일치시켜야 함

```java
@GetMapping(value="/variable1/{variable}")
public String getVariable1(@PathVariable String variable) {
    return variable;
}
```
- 아래 방식은 @GetMapping에서 사용된 {변수}의 이름과 메소드의 매개변수가 다를 경우 사용하는 방식
- 변수의 관리 용이를 위해 사용되는 방식

```java
@GetMapping(value="/variable2/{variable}")
pubic String getVariable2(@PathVariable("variable") String var) {
    return var;
}
```

## @RequestParam
- GET 형식의 요청에서 쿼리 문자열을 전달하기 위해 사용되는 방법
- '?'를 기준으로 우측에 {키}={값}의 형태로 전달되며, 복수 형태로 전달할 경우 &를 사용함

> http://localhost:8080/api/v1/get-api/request1?name=flature&email=thinkground.flature@gmail.com&organization=thinkground

```java
@GetMapping(value="/request")
public String getRequestParam1(
    @RequestParam String name,
    @RequestParam String email,
    @RequestParam String organization) {
        return name + " " + email + " " + organization;
}
```

- 아래 예시 코드는 어떤 요청값이 들어올지 모를 경우 사용하는 방식

```java
@GetMapping(value="/request2")
public String getRequestParam2(@RequestParam Map<String, String> param) {}
    StringBuilder sb = new StringBuilder();
    param.entrySet().forEach(map -> {
        sb.append(map.getKey() + ":" + map.getValue() + "\n");
    });
    return sb.toString();
}
```

## DTO 사용
- GET 형식의 요청에서 쿼리 문자열을 전달하기 위해 사용되는 방법
- key와 value가 정해져 있지만, 받아야할 파라미터가 많을 경우 DTO 객체를 사용한 방식

```java
@GetMapping(value="/request3")
public String getRequestParam3(MemberDTO memberDTO) {
    return memberDTO.toString();
}

```java
public class MemberDTO {
    private String name;
    private String email;
    private String organization;
}


# POST API

## Post API
- 리소스를 추가하기 위해 사용되는 API
- @PostMapping : POST API를 제작하기 위해 사용되는 어노테이션(Annotation)
                 @RequestMapping + POST method의 조합
- 일반적으로 추가하고자 하는 Resource를 http body에 추가하여 서버에 요청
- 그렇기 때문에 @RequestBody를 이용하여 body에 담겨 있는 값을 받아야 함

```java
@PostMapping(value="/member")
public String postMember(@RequestBody Map<String, Object> postData) {
    StringBuilder sb = new StringBuilder();

    postData.entrySet().forEach(map -> {
        sb.append(map.getKey() + ":" + map.getValue()+ "\n");
    });

    return sb.toString();
}

## DTO 사용

- key와 value가 정해져 있지만, 받아야할때 파라미터가 많을 경우 DTO 객체를 사용한 방식

```java
@PostMapping(value="/member2")
public String postMemberDto(@RequestBody MemberDTO memberDTO) {
    return memberDTO.toString();
}


# Swagger
- 협업을 위해 필요한 라이브러리

## Swagger란?
- 서버로 요청되는 API리스트를 HTML 화면으로 문서화하여 테스트 할 수 있는 라이브러리
- 이 라이브러리는 서버가 가동되면서 @RestController를 읽어 API를 분석하여 HTML 문서를 작성함
- 작성일(21.07.24) 기준 3.0.0 버전까지 출시되었음
- 이 영상에서는 가장 많이 사용하고 있는 2.9.2 버전을 사용할 예정

## Swagger가 필요한 이유
- REST API의 스펙을 문서화 하는 것은 매우 중요
- API를 변경할 때마다 Reference 문서를 계속 바꿔야하는 불편함이 있음

## Swagger 설정 방법
- @Configuration : 어노테이션 기반의 환경 구성을 돕는 어노테이션
        
                   IoC Container에게 해당 클래스를 Bean 구성 Class임을 알려줌
- @Bean : 개발자가 직접 제어가 불가능한 외부 라이브러리 들을 Bean으로 만들 경우에 사용


# PUT, DELETE API

## Put API
- 해당 리소스가 존재하면 갱신하고, 리소스가 없을 경우에는 새로 생성해주는 API
- 업데이트를 위한 메소드
- 기본적인 동작 방식은 Post API와 동일

## Delete API
- 서버를 통해 리소스를 삭제하기 위해 사용되는 API
- 일반적으로 @PathVariable을 통해 리소스 ID 등을 받아 처리

## ResponseEntity
- Spring Framework에서 제공하는 클래스 중 HttpEntity라는 클래스를 상속받아 사용하는 클래스
- 사용자의 HttpRequest에 대한 응답 데이터를 포함
- 포함하는 클래스
    - HttpStatus
    - HttpHeaders
    - HttpBody

# Lombok

## Lombok 이란?
- 반복되는 메소드를 Annotation을 사용하여 자동으로 작성해주는 라이브러리
- 일반적으로 VO, DTO, Model, Entity 등의 데이터 클래스에서 주로 사용됨
- 대표적으로 많이 사용되는 Annotation
    - @Getter
    - @Setter
    - @NoArgConstructor
    - @AllArgConstructor
    - @Data
    - @ToString

## Lombok 사용법
라이브러리 의존성 설정

```xml ~ pom.xml
<dependencies>
...
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
...
</dependencies>
```
## Lombok의 대표적인 어노테이션
@Getter // @Setter
- 해당 클래스애 선언되어 있는 필드를 기반으로 'getField', 'setField'와 같은 식으로 자동으로 메소드를 생성

@NoArgsConstructor // @AllArgsConstructor // @RequiredArgsConstructor
- @NoArgsConstructor : 파라미터가 없는 생성자를 생성
- @AllArgsConstructor : 모든 필드값을 파라미터로 갖는 생성자를 생성
- @RequiredArgsConstructor : 필드값 중 final이나 @NotNull인 값을 갖는 생성자를 생성
    - 많이 사용되지 않음

@ToString
- toString 메소드를 자동으로 생성해주는기능
- @ToString 어노테이션에 exclude 속성을 사용하여 특정 필드를 toString에서 제외시킬 수 있음

```java
@ToString
public class MemberDTO {
    private String name;
    private String email;
    private String organization;
}
```

```java
@ToString(exclude="email")
public class MemberDTO {
    private String name;
    private String email;
    private String organization;
}
```

```java
@Override
public String toString() {
    return "MemberDTO{" +
        "name='" + name + '\'' +
        ", email='" + email + '\'' +
        ", organization='" + organization + '\'' +
        '}';
}
```

@EqulasAndHashCode
- equals, hashCode 메소드를 자동으로 생성
- equals : 두 객체의 내용이 같은지 동등성(equality)를 비교하는 연산자
- hashCode : 두 객체가 같은 객체인지 동일성(identity)를 비교하는 연산자

- callSuper 속성을 통해 메소드 생성시 부모 클래스의 필드까지 고려할지 여부 설정 가능
    - callSuper = true -> 부모 클래스 필드 값들도 동일한지 체크

@Data

- 해당 어노테이션을 사용하면, 앞서 나온 기능들을 한번에 추가해 줌
    - @Getter
    - @Setter
    - @RequiredArgsConstructor
    - @ToString
    - @EqualsAndHashCode


# Entity, DAO, Repository, DTO

## Spring Boot 서비스 구조
<img src="스프링 서비스 구조.png">

> Clinet <--DTO--> COntroller <--DTO--> Service <--Entity--> DAO(Repository) <-- Entity --> DB

## Entity(Domain)
- 데이터베이스에 쓰일 컬럼과 여러 엔티티 간의 연관관계를 정의
- 데이터베이스의 테이블을 하나의 엔티티로 생각해도 무방함
- 실제 데이터베이스의 테이블과 1:1로 매핑됨
- 이 클래스의 필드는 각 테이블 내부의 컬럼(Column)을 의미

## Repository
- Entity에 의해 생성된 데이터베이스에 접근하는 메소드를 사용하기 위한 인터페이스
- Service와 DB를 연결하는 고리의 역할을 수행
- 데이터베이스에 적용하고자 하는 CRUD를 정의하는 영역

## DAO(Data Access Object)
- 데이터베이스에 접근하는 객체를 의미(Persistance Layer)
- Service가 DB에 연결할 수 있게 해주는 역할
- DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전담

## DTO(Data Transfer Object)
- DTO는 VO(Value Object)로 불리기도 하며, 계층간 데이터 교환을 위한 객체를 의미
- VO의 경우 Read Only의 개념을 가지고 있음


# ORM과 JPA

## ORM(Object Relational Mapping) 이란?
- 어플리케이션의 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 의미
    - Java의 데이터 클래스와 관계형 데이터베이스의 테이블을 매핑
- 객체지향 프로그래밍과 관계형 데이터베이스의 차이로 발생하는 제약사항을 해결해주는 역할을 수행
- 대표적으로 JPA, Hibernate 등이 있음(Persistent API)

## ORM의 장점
- SQL 쿼리가 아닌 직관적인 코드로 데이터를 조작할 수 있음
    - 개발자가 보다 비즈니스 로직에 집중할 수 있음
- 재사용 및 유지보수가 편리
    - ORM은 독립적으로 작성되어 있어 재사용이 가능
    - 매핑정보를 명확하게 설계하기 때문에 따로 데이터베이스를 볼 필요가 없음
- DBMS에 대한 종속성이 줄어둠
    - DBMS를 교체하는 작업을 비교적 적은 리스크로 수행 가능

## ORM의 단점
- 복잡성이 커질 경우 ORM만으로 구현하기 어려움
    - 직접 쿼리를 구현하지 않아 복잡한 설계가 어려움
- 잘못 구현할 경우 속도 저하 발생
- 대형 쿼리는 별도의 튜닝이 필요할 수 있음

## JPA(Java Persistance API) 란?
- JPA는 Java Persistance API의 줄임말이며, ORM과 관련된 인터페이스의 모음
- Java 진영에서 표준 ORM으로 채택되어 있음
- ORM이 큰 개념이라고 하면, JPA는 더 구체화 시킨 스펙을 포함하고 있음

## Hibernate
- ORM Framework중 하나
- JPA의 실제 구현체 중 하나이며, 현재 JPA 구현체 중 가장 많이 사용됨
- JPA ---- EclipseLink
      ---- Hibernate
      ---- DataNucleus

## Spring Data JPA
Spring Framework에서 JPA를 편리하게 사용할 수 있게 지원하는 라이브러리
- CRUD 처리용 인터페이스 제공
- Repository 개발 시 인터페이스만 작성하면 구현 객체를 동적으로 생성해서 주입
- 데이터 접근 계층 개발시 인터페이스만 작성해도 됨

Hibernate에서 자주 사용되는 기능을 조금 더 쉽게 사용할 수 있게 구현









